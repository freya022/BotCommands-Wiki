{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the BotCommands wiki!","text":"<p>Have a look around the different categories on how to use this framework</p> <p>If you don't find a wiki page you need, you should check out the examples</p>"},{"location":"using-components/","title":"Using components","text":"<p>This requires a database to be set up!</p> <p>Components provided by the framework are your usual Discord components with additional features, they can be configured to:</p> <ul> <li>Be usable once</li> <li>Have timeouts</li> <li>Have method handlers or callbacks</li> <li>Have constraints (allow list for users/roles/permissions)</li> </ul> <p>To get access to them, you can use the <code>Buttons</code> and <code>SelectMenus</code> factories, as well as <code>Components</code> to delete them manually and make groups.</p> <p>Configuring components with Java</p> <p>When configuring components, you need to use the framework's methods first,  and then use the JDA methods, and finally build.</p> <p>Disabling classes depending on components</p> <p>You can use <code>@RequiresComponents</code> if you want your class to be disabled when the components are not available.</p>"},{"location":"using-components/#persistent-components","title":"Persistent components","text":"<p>They are components that still work after a restart, their handlers are methods identified by their handler name, set in <code>@JDAButtonListener</code>) / <code>@JDASelectMenuListener</code>.</p> <p>Persistent components have no timeout by default, as their purpose is to be long-lived, however, you can set one using <code>timeout</code>, which accept a timeout handler name, set with <code>@ComponentTimeoutHandler</code>.</p> <p>Info</p> <p>Components which expired while the bot was offline will run their timeout handlers at startup.</p>"},{"location":"using-components/#example","title":"Example","text":"KotlinJava <p>In Kotlin, we can use extensions to make sure we call our component handlers in a type-safe manner, this way you will have a compile error if the handler and the arguments don't match, it will also allow using handlers without setting a name.</p> <p>This can only be used when the input argument types matches the handler parameter types.</p> <p>Note</p> <p>A similar <code>timeoutWith</code> function exists for timeouts.</p> <pre><code>@Command\nclass SlashPersistentClicker(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"clicker\", subcommand = \"persistent\", description = \"Creates a button you can infinitely click\")\n    suspend fun onSlashClicker(event: GuildSlashEvent) {\n        val button = createButton(event, count = 0)\n        event.replyComponents(row(button)).await()\n    }\n\n    // No need for a name if you use the type-safe \"bindWith\" extensions\n    @JDAButtonListener\n    suspend fun onCookieClick(event: ButtonEvent, @ComponentData count: Int) {\n        val button = createButton(event, count + 1)\n        event.editComponents(row(button)).await()\n    }\n\n    // Same thing here, no name required\n    @ComponentTimeoutHandler\n    fun onCookieTimeout(timeout: ComponentTimeoutData, @TimeoutData count: Int) {\n        println(\"User finished clicking $count cookies\")\n    }\n\n    private suspend fun createButton(event: Interaction, @ComponentData count: Int): Button {\n        // Create a primary-styled button\n        return buttons.primary(\"$count cookies\")\n            // Sets the emoji on the button,\n            // this can be an unicode emoji, an alias or even a custom emoji\n            .withEmoji(\"cookie\")\n\n            // Create a button that can be used even after a restart\n            .persistent {\n                // Make it so this button is only usable once\n                // this is not an issue as we recreate the button everytime.\n                // If this wasn't usable only once, the timeout would run for each button.\n                singleUse = true\n\n                // Only allow the caller to use the button\n                constraints += event.user\n\n                // Timeout and call the method after the button hasn't been used for a day\n                // The timeout gets cancelled if the button is invalidated\n                timeoutWith(1.days, ::onCookieTimeout, count)\n\n                // When clicked, run the onCookieClick method with the count\n                // Extension for type-safe binding, no need to type the name\n                bindWith(::onCookieClick, count)\n            }\n    }\n}\n</code></pre> <p>You can also use components without setting a handler, and instead await the event:</p> <pre><code>@Command\nclass SlashClickWaiter(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"click_waiter\", description = \"Sends a button and waits for it to be clicked\")\n    suspend fun onSlashClickWaiter(event: GuildSlashEvent) {\n        val button = buttons.primary(\"Click me\").ephemeral {\n            // Make it so this button is only usable once\n            singleUse = true\n\n            // Only allow the caller to use the button\n            constraints += event.user\n        }\n        event.replyComponents(row(button)).await()\n\n        // Wait for the allowed user to click the button\n        val buttonEvent: ButtonEvent = button.awaitOrNull() // (1)!\n            ?: return event.hook\n                .replaceWith(\"Expired!\")\n                .awaitUnit() // (2)!\n\n        buttonEvent.editMessage(\"!\")\n            // Replace the entire message\n            .setReplace(true)\n            // Delete after 5 seconds\n            .deleteDelayed(5.seconds)\n            // Note that the coroutine will resume *after the message is deleted*\n            .await()\n    }\n}\n</code></pre> <ol> <li> <p><code>awaitOrNull</code> returns <code>null</code> when the component expired, useful when combined with an elvis operator, this is the equivalent of a <code>try catch</code> on <code>TimeoutCancellationException</code>. Since there is no timeout set here, the default duration is used.</p> </li> <li> <p><code>awaitUnit</code> is an extension to await and then return <code>Unit</code>,  which helps in common scenarios where you want to reply using an elvis operator.</p> </li> </ol> <pre><code>@Command\npublic class SlashClickerPersistent extends ApplicationCommand {\n    // Since Java doesn't have the same method references as Kotlin,\n    // we should use a constant name, so we don't have to type it more than once.\n    private static final String COOKIE_BUTTON_NAME = \"SlashPersistentClicker: cookie\";\n\n    private final Buttons buttons;\n\n    public SlashClickerPersistent(Buttons buttons) {\n        this.buttons = buttons;\n    }\n\n    @JDASlashCommand(name = \"clicker\", subcommand = \"persistent\", description = \"Creates a button you can infinitely click\")\n    public void onSlashClicker(GuildSlashEvent event) {\n        final Button button = createButton(event, 0);\n        event.replyComponents(ActionRow.of(button)).queue();\n    }\n\n    // The name should be unique,\n    // I recommend naming the handler \"[ClassName]: [purpose]\"\n    // And the name would be \"on[purpose]Click\"\n    @JDAButtonListener(COOKIE_BUTTON_NAME)\n    public void onCookieClick(ButtonEvent event, @ComponentData int count) {\n        final Button newButton = createButton(event, count + 1);\n        event.editComponents(ActionRow.of(newButton)).queue();\n    }\n\n    // Same thing here, names don't collide with other types of listener\n    @ComponentTimeoutHandler(COOKIE_BUTTON_NAME)\n    public void onCookieTimeout(ComponentTimeoutData timeout, @TimeoutData String count) {\n        System.out.println(\"User finished clicking \" + count + \" cookies\");\n    }\n\n    private Button createButton(Interaction event, int count) {\n        // Create a primary-styled button\n        return buttons.primary(count + \" cookies\")\n                // Sets the emoji on the button,\n                // this can be an unicode emoji, an alias or even a custom emoji\n                .withEmoji(\"cookie\")\n\n                // Create a button that can be used even after a restart\n                .persistent()\n\n                // Make it so this button is only usable once\n                // this is not an issue as we recreate the button everytime.\n                // If this wasn't usable only once, the timeout would run for each button.\n                .singleUse(true)\n\n                // Only allow the caller to use the button\n                .constraints(interactionConstraints -&gt; {\n                    interactionConstraints.addUsers(event.getUser());\n                })\n\n                // Timeout and call the method after the button hasn't been used for a day\n                // The timeout gets cancelled if the button is invalidated\n                .timeout(Duration.ofDays(1), COOKIE_BUTTON_NAME, count)\n\n                // When clicked, run the onCookieClick method with the count\n                .bindTo(COOKIE_BUTTON_NAME, count)\n                .build();\n    }\n}\n</code></pre>"},{"location":"using-components/#ephemeral-components","title":"Ephemeral components","text":"<p>They are components which get invalidated after a restart, meaning they can no longer be used, their handlers are callbacks, which can also have a timeout set, and also use callbacks.</p> <p>Info</p> <p>\"Invalidated\" means that they are deleted from the database, but not necessarily from the message.</p> <p>Ephemeral components have a default timeout set in <code>Components.defaultTimeout</code>, which can be changed.</p>"},{"location":"using-components/#example_1","title":"Example","text":"KotlinJava <pre><code>@Command\nclass SlashEphemeralClicker(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"clicker\", subcommand = \"ephemeral\", description = \"Creates a button you can click until the bot restarts\")\n    suspend fun onSlashClicker(event: GuildSlashEvent) {\n        val button = createButton(event, count = 0)\n        event.replyComponents(row(button)).await()\n    }\n\n    private suspend fun createButton(event: Interaction, count: Int): Button {\n        // Create a primary-styled button\n        return buttons.primary(\"$count cookies\")\n            // Sets the emoji on the button,\n            // this can be an unicode emoji, an alias or even a custom emoji\n            .withEmoji(\"cookie\")\n\n            // Create a button that can be used until the bot restarts\n            .ephemeral {\n                // Make it so this button is only usable once\n                // this is not an issue as we recreate the button everytime.\n                // If this wasn't usable only once, the timeout would run for each button.\n                singleUse = true\n\n                // Only allow the caller to use the button\n                constraints += event.user\n\n                // Run this callback after the button hasn't been used for a day\n                // The timeout gets cancelled if the button is invalidated\n                timeout(1.days) {\n                    println(\"User finished clicking $count cookies\")\n                }\n\n                // When clicked, run this callback\n                bindTo { buttonEvent -&gt;\n                    val newButton = createButton(buttonEvent, count + 1)\n                    buttonEvent.editComponents(row(newButton)).await()\n                }\n            }\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashClickerEphemeral extends ApplicationCommand {\n    private final Buttons buttons;\n\n    public SlashClickerEphemeral(Buttons buttons) {\n        this.buttons = buttons;\n    }\n\n    @JDASlashCommand(name = \"clicker\", subcommand = \"ephemeral\", description = \"Creates a button you can click until the bot restarts\")\n    public void onSlashClicker(GuildSlashEvent event) {\n        final Button button = createButton(event, 0);\n        event.replyComponents(ActionRow.of(button)).queue();\n    }\n\n    private Button createButton(Interaction event, int count) {\n        // Create a primary-styled button\n        return buttons.primary(count + \" cookies\")\n                // Sets the emoji on the button,\n                // this can be an unicode emoji, an alias or even a custom emoji\n                .withEmoji(\"cookie\")\n\n                // Create a button that can be used until the bot restarts\n                .ephemeral()\n\n                // Make it so this button is only usable once\n                // this is not an issue as we recreate the button everytime.\n                // If this wasn't usable only once, the timeout would run for each button.\n                .singleUse(true)\n\n                // Only allow the caller to use the button\n                .constraints(interactionConstraints -&gt; {\n                    interactionConstraints.addUsers(event.getUser());\n                })\n\n                // Run this callback after the button hasn't been used for a day\n                // The timeout gets cancelled if the button is invalidated\n                .timeout(Duration.ofDays(1), () -&gt; {\n                    System.out.println(\"User finished clicking \" + count + \" cookies\");\n                })\n\n                // When clicked, run this callback\n                .bindTo(buttonEvent -&gt; {\n                    final Button newButton = createButton(buttonEvent, count + 1);\n                    buttonEvent.editComponents(ActionRow.of(newButton)).queue();\n                })\n                .build();\n    }\n}\n</code></pre>"},{"location":"using-components/#component-groups","title":"Component groups","text":"<p>Component groups can be created in any component factory, and allow you to configure one timeout for all components.</p> <p>Also, when one of them gets invalidated (after being used with <code>singleUse = true</code>), the entire group gets invalidated.</p> <p>For example, this can be useful when the user needs to use a single component, once.</p> <p>Ephemeral components in groups</p> <p>If you put ephemeral components in your group, you must disable the timeout with <code>noTimeout()</code>.</p> <p>The timeout works similarly to components, except the annotated handler is a <code>@GroupTimeoutHandler</code>.</p>"},{"location":"using-components/#example_2","title":"Example","text":"KotlinJava <pre><code>@Command\nclass SlashClickGroup(private val buttons: Buttons) : ApplicationCommand() {\n    @JDASlashCommand(name = \"click_group\", description = \"Sends two buttons and waits for any of them to be clicked\")\n    suspend fun onSlashClickGroup(event: GuildSlashEvent) {\n        val firstButton = buttons.primary(\"1\").ephemeral {\n            // Disable the timeout so we can use a group timeout\n            noTimeout()\n\n            // Make it so this button is only usable once\n            singleUse = true\n\n            // Only allow the caller to use the button\n            constraints += event.user\n        }\n        val secondButton = buttons.primary(\"2\").ephemeral {\n            // Disable the timeout so we can use a group timeout\n            noTimeout()\n\n            // Make it so this button is only usable once\n            singleUse = true\n\n            // Only allow the caller to use the button\n            constraints += event.user\n        }\n        // Construct our group, make it expire after 1 minute\n        val group = buttons.group(firstButton, secondButton).ephemeral {\n            timeout(1.minutes)\n        }\n        event.replyComponents(row(firstButton, secondButton)).await()\n\n        // Wait for the allowed user to click one of the buttons\n        val buttonEvent = group.awaitAnyOrNull&lt;ButtonEvent&gt;()\n            ?: return event.hook\n                .replaceWith(\"Expired!\")\n                .awaitUnit()\n\n        // Disable the other button\n        buttonEvent.editButton(buttonEvent.button.asDisabled()).await()\n        buttonEvent.hook.editOriginal(\"Try clicking the other button, you can't :^)\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashClickGroup extends ApplicationCommand {\n    // Since Java doesn't have the same method references as Kotlin,\n    // we should use a constant name, so we don't have to type it more than once.\n    private static final String COOKIE_BUTTON_NAME = \"SlashPersistentClicker: cookie\";\n\n    private final Buttons buttons;\n\n    public SlashClickGroup(Buttons buttons) {\n        this.buttons = buttons;\n    }\n\n    @JDASlashCommand(name = \"click_group\", description = \"Sends two buttons and waits for any of them to be clicked\")\n    public void onSlashClicker(GuildSlashEvent event) {\n        final var firstButton = buttons.primary(\"1\")\n                .ephemeral()\n                // Disable the timeout so we can use a group timeout\n                .noTimeout()\n\n                // Make it so this button is only usable once\n                .singleUse(true)\n\n                // Only allow the caller to use the button\n                .constraints(interactionConstraints -&gt; {\n                    interactionConstraints.addUsers(event.getUser());\n                })\n\n                // Run this method when the button is clicked\n                .bindTo(this::onButtonClick)\n                .build();\n\n        final var secondButton = buttons.primary(\"2\")\n                .ephemeral()\n                // Disable the timeout so we can use a group timeout\n                .noTimeout()\n\n                // Make it so this button is only usable once\n                .singleUse(true)\n\n                // Only allow the caller to use the button\n                .constraints(interactionConstraints -&gt; {\n                    interactionConstraints.addUsers(event.getUser());\n                })\n\n                // Run this method when the button is clicked\n                .bindTo(this::onButtonClick)\n                .build();\n        // Construct our group, make it expire after 1 minute\n        buttons.group(firstButton, secondButton)\n                .ephemeral()\n                .timeout(Duration.ofMinutes(1), () -&gt; onButtonTimeout(event))\n                .build();\n\n        event.replyComponents(ActionRow.of(firstButton, secondButton)).queue();\n    }\n\n    private void onButtonClick(ButtonEvent event) {\n        event.editButton(event.getButton().asDisabled()).queue();\n        event.getHook().editOriginal(\"Try clicking the other button, you can't :^)\").queue();\n    }\n\n    private void onButtonTimeout(GuildSlashEvent event) {\n        event.getHook()\n                .editOriginal(\"Expired!\")\n                .setReplace(true)\n                .queue();\n    }\n}\n</code></pre>"},{"location":"using-components/#filtering","title":"Filtering","text":"<p>Components also support filtering, you can use <code>addFilter</code> with either the filter type, or the filter instance directly.</p> <p>Passing custom filter instances</p> <p>You cannot pass filters that cannot be obtained via dependency injection, this includes composite filters (using <code>and</code> / <code>or</code>),  see <code>ComponentInteractionFilter</code> for more details</p>"},{"location":"using-components/#creating-a-filter","title":"Creating a filter","text":"<p>Creating a filter can be done by implementing <code>ComponentInteractionFilter</code> and registering it as a service,  they run when a component is about to be executed.</p> <p>Lets create a filter that allows the component to be usable in a predefined one channel:</p> <p>Note</p> <p>Your filter needs to not be global in order to be used on specific components.</p> KotlinJava GeneralChannelFilter.kt<pre><code>@BService\nclass GeneralChannelFilter : ComponentInteractionFilter&lt;String/*(1)!*/&gt; {\n    private val channelId = 722891685755093076\n\n    // So we can apply this filter on specific components\n    override val global: Boolean = false\n\n    override suspend fun checkSuspend(\n        event: GenericComponentInteractionCreateEvent,\n        handlerName: String?\n    ): String? {\n        if (event.channelIdLong == channelId)\n            return \"This button can only be used in &lt;#$channelId&gt;\"\n        return null\n    }\n}\n</code></pre> <ol> <li>This is the return type of the filter, this will be passed as <code>userData</code> in your rejection handler.</li> </ol> GeneralChannelFilter.java<pre><code>@BService\npublic class GeneralChannelFilter implements ComponentInteractionFilter&lt;String/*(1)!*/&gt; {\n    private static final long CHANNEL_ID = 722891685755093076L;\n\n    @Override\n    public boolean getGlobal() {\n        // So we can apply this filter on specific components\n        return false;\n    }\n\n    @Nullable\n    @Override\n    public String check(@NotNull GenericComponentInteractionCreateEvent event,\n                        @Nullable String handlerName) {\n        if (event.getChannelIdLong() == CHANNEL_ID)\n            return \"This button can only be used in &lt;#\" + CHANNEL_ID + \"&gt;\";\n        return null;\n    }\n}\n</code></pre> <ol> <li>This is the return type of the filter, this will be passed as <code>userData</code> in your rejection handler.</li> </ol>"},{"location":"using-components/#creating-a-rejection-handler","title":"Creating a rejection handler","text":"<p>You must then create a single rejection handler for all your filters,  it runs when one of your filters fails.</p> <p>Note</p> <p>All of your filters must have the same return type as the rejection handler (the generic you set on the interface).</p> KotlinJava ComponentRejectionHandler.kt<pre><code>@BService\nclass ComponentRejectionHandler : ComponentInteractionRejectionHandler&lt;String/*(1)!*/&gt; {\n    override suspend fun handleSuspend(\n        event: GenericComponentInteractionCreateEvent,\n        handlerName: String?,\n        userData: String\n    ) {\n        event.reply_(userData, ephemeral = true).await()\n    }\n}\n</code></pre> <ol> <li>This is what was returned by one of your filters, this will be passed as <code>userData</code>.</li> </ol> ComponentRejectionHandler.java<pre><code>@BService\npublic class ComponentRejectionHandler implements ComponentInteractionRejectionHandler&lt;String/*(1)!*/&gt; {\n    @Override\n    public void handle(@NotNull GenericComponentInteractionCreateEvent event,\n                       @Nullable String handlerName,\n                       @NotNull String userData) {\n        event.reply(userData).setEphemeral(true).queue();\n    }\n}\n</code></pre> <ol> <li>This is what was returned by one of your filters, this will be passed as <code>userData</code>.</li> </ol>"},{"location":"using-components/#using-an-existing-filter","title":"Using an existing filter","text":"<p>Now that your filter has been created, you can reference it in your component.</p> KotlinJava <pre><code>buttons.primary(\"Can't click me\").ephemeral {\n    filters += filter&lt;GeneralChannelFilter&gt;()\n}\n</code></pre> <pre><code>buttons.primary(\"Can't click me\")\n    .ephemeral()\n    .addFilter(GeneralChannelFilter.class)\n    .build()\n</code></pre>"},{"location":"using-components/#rate-limiting","title":"Rate limiting","text":"<p>Rate limiting / cooldowns can be applied to components by using <code>rateLimitReference()</code>, then referencing an existing rate limiter.</p>"},{"location":"using-components/#using-an-existing-rate-limiter","title":"Using an existing rate limiter","text":"KotlinJava <pre><code>buttons.primary(\"Can't click me too fast\").ephemeral {\n    rateLimitReference(\"name of the rate limiter\")\n}\n</code></pre> <pre><code>buttons.primary(\"Can't click me too fast\")\n    .ephemeral()\n    .rateLimitReference(\"name of the rate limiter\")\n    .build()\n</code></pre>"},{"location":"setup/getting-started/","title":"Starting from scratch","text":"<p>Start by creating a project either using Maven or Gradle, it must run on Java 17+, I recommend using Java 21.</p> <p>Creating a new Maven project</p> <p>When creating a Maven project in IntelliJ, do not choose <code>Maven Archetype</code> in <code>Generators</code>, you must use <code>New Project</code>.</p>"},{"location":"setup/getting-started/#adding-the-dependencies","title":"Adding the dependencies","text":"<p>The only strictly necessary dependencies are the framework and JDA:</p> <p> </p> <p>Omit the <code>v</code> prefix from the version, e.g. <code>5.0.0-beta.18</code>.</p> MavenKotlin Gradle <pre><code>&lt;dependencies&gt;\n    ...\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;net.dv8tion&lt;/groupId&gt;\n        &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n        &lt;version&gt;JDA_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.github.freya022&lt;/groupId&gt;\n        &lt;artifactId&gt;BotCommands&lt;/artifactId&gt;\n        &lt;version&gt;BC_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>repositories {\n    ...\n    mavenCentral()\n}\n\ndependencies {\n    ...\n\n    implementation(\"net.dv8tion:JDA:JDA_VERSION\")\n    implementation(\"io.github.freya022:BotCommands:BC_VERSION\")\n}\n</code></pre>"},{"location":"setup/getting-started/#adding-logging","title":"Adding logging","text":"<p>Any SLF4J compatible logger should work; I recommend logback, which you can learn more here.</p>"},{"location":"setup/getting-started/#creating-a-config-service","title":"Creating a config service","text":"<p>Create a small <code>Config</code> service, it can be a simple object with the properties you need,  this will be useful when running your bot.</p> Example KotlinJava <pre><code>class Config(val token: String, val ownerIds: List&lt;Long&gt;) {\n    companion object {\n        // Makes a service factory out of this property getter\n        @get:BService\n        val instance by lazy {\n            // Load your config\n        }\n    }\n}\n</code></pre> <pre><code>public class Config {\n    private static Config INSTANCE = null;\n\n    private String token;\n    private List&lt;Long&gt; ownerIds;\n\n    public String getToken() { return token; }\n    public List&lt;Long&gt; getOwnerIds() { return ownerIds; }\n\n    @BService // Makes this method a service factory that outputs Config objects\n    public static Config getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = // Load your config\n        }\n\n        return INSTANCE;\n    }\n}\n</code></pre> <p>Info</p> <p>You can refer to the Dependency Injection page for more details</p>"},{"location":"setup/getting-started/#creating-the-main-class","title":"Creating the main class","text":"<p>As we've used a singleton pattern for your <code>Config</code> class, we can get the same instance anywhere,  and still be able to get it as a service.</p> Built-in DISpring IoC <p>All you need to do to start the framework is <code>BotCommands#create</code>:</p> KotlinJava Main.kt - Main function<pre><code>val config = Config.instance\n\nBotCommands.create {\n    // Optionally set the owner IDs if they differ from the owners in the Discord dashboard\n    // addPredefinedOwners(config.ownerIds)\n\n    // Add the base package of the application\n    // All services and commands inside will be loaded\n    addSearchPath(\"io.github.name.bot\")\n\n    textCommands {\n        usePingAsPrefix = true // The bot will respond to his mention/ping\n    }\n}    \n</code></pre> Main.java - Main method<pre><code>final var config = Config.getInstance();\n\nBotCommands.create(builder -&gt; {\n    // Optionally set the owner IDs if they differ from the owners in the Discord dashboard\n    // builder.addPredefinedOwners(config.getOwnerIds());\n\n    // Add the base package of the application\n    // All services and commands inside will be loaded\n    builder.addSearchPath(\"io.github.name.bot\");\n\n    builder.textCommands(textCommands -&gt; {\n        textCommands.usePingAsPrefix(true);\n    });\n});\n</code></pre> <p>The framework also supports Spring IoC, add the library, add the package of your application with the <code>scanBasePackages</code> value of your <code>@SpringBootApplication</code>, and voil\u00e0.</p> <p>Note</p> <p>You can always disable it by adding <code>BotCommandsAutoConfiguration</code> to the <code>exclude</code> value of your <code>@SpringBootApplication</code>.</p> <p>Configuration of the framework is then done either by using application properties (with the prefix being either <code>botcommands</code> or <code>jda</code>), or by implementing configurers, see the <code>BConfigurer</code> inheritors.</p> Kotlin - Using a custom <code>CoroutineEventManager</code> <p>I recommend creating a custom <code>CoroutineEventManager</code>, that way you can configure the amount of threads or their names, which may be convenient in logs.</p> <p>You can do so by implementing a <code>ICoroutineEventManagerSupplier</code> service,  with the help of <code>namedDefaultScope</code>: <pre><code>@BService\nclass CoroutineEventManagerSupplier : ICoroutineEventManagerSupplier {\n    override fun get(): CoroutineEventManager {\n        val scope = namedDefaultScope(\"WikiBot Coroutine\", corePoolSize = 4)\n        return CoroutineEventManager(scope)\n    }\n}\n</code></pre></p> <p>Warning</p> <p>JDA must be created after the framework is built, as the framework listens to JDA events and must not skip any of these, you will need to make a service extending <code>JDAService</code>.</p>"},{"location":"setup/getting-started/#creating-a-jdaservice","title":"Creating a <code>JDAService</code>","text":"<p>Now you've been able to start the framework, all your services (such as <code>Config</code> for the moment) should be loaded,  but you must now have a way to start JDA, implementing <code>JDAService</code> will let you start the bot in a convenient place.</p> KotlinJava <pre><code>@BService\nclass Bot(private val config: Config) : JDAService() {\n    override val intents: Set&lt;GatewayIntent&gt; = defaultIntents(/* _Additional_ intents */)\n\n    override val cacheFlags: Set&lt;CacheFlag&gt; = setOf(/* _Additional_ cache flags */)\n\n    override fun createJDA(event: BReadyEvent, eventManager: IEventManager) {\n        light(\n            config.token,\n            activity = Activity.customStatus(\"In Kotlin with \u2764\ufe0f\")\n        ) {\n            // Other configs\n        }\n    }\n}\n</code></pre> <pre><code>@BService\npublic class Bot extends JDAService {\n    private final Config config;\n\n    public Bot(Config config) {\n        this.config = config;\n    }\n\n    @NotNull\n    @Override\n    public Set&lt;CacheFlag&gt; getCacheFlags() {\n        return Set.of(/* _Additional_ cache flags */);\n    }\n\n    @NotNull\n    @Override\n    public Set&lt;GatewayIntent&gt; getIntents() {\n        return defaultIntents(/* _Additional_ intents */);\n    }\n\n    @Override\n    public void createJDA(@NotNull BReadyEvent event, @NotNull IEventManager eventManager) {\n        light(config.getToken())\n                .setActivity(Activity.customStatus(\"In Java with \u2764\ufe0f\"))\n                .build();\n    }\n}\n</code></pre> <p>Info</p> <p>Implementing <code>JDAService</code> guarantees that your bot will connect at the right time,  and provides a way for the framework to check missing intents and missing cache flags before your bot even starts.</p> <p>You can retrieve a <code>JDA</code> instance once this service has finished constructing,  this also implies that you cannot request a <code>JDA</code> before <code>InjectedJDAEvent</code> has fired.</p> <p>You can now run your bot! Assuming you have done your config class and provided at least the token and owner IDs,  you should be able to run the help command, by mentioning your bot <code>@YourBot help</code>.</p>"},{"location":"setup/getting-started/#optional-add-stacktrace-decoroutinator","title":"Optional - Add <code>stacktrace-decoroutinator</code>","text":"<p>I recommend adding <code>stacktrace-decoroutinator</code>,  which will help you get clearer stacktrace when using Kotlin coroutines.</p> <p>Note</p> <p>Java users also benefit from it as it may help debug framework issues.</p> <p></p> MavenKotlin Gradle <pre><code>&lt;dependencies&gt;\n    ...\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;dev.reformator.stacktracedecoroutinator&lt;/groupId&gt;\n        &lt;artifactId&gt;stacktrace-decoroutinator-jvm&lt;/artifactId&gt;\n        &lt;version&gt;SD_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>repositories {\n    ...\n    mavenCentral()\n}\n\ndependencies {\n    ...\n\n    implementation(\"dev.reformator.stacktracedecoroutinator:stacktrace-decoroutinator-jvm:SD_VERSION\")\n}\n</code></pre> <p>Finally, load it on the first lines of your main program:</p> KotlinJava <pre><code>// stacktrace-decoroutinator has issues when reloading with hotswap agent\nif (\"-XX:+AllowEnhancedClassRedefinition\" in ManagementFactory.getRuntimeMXBean().inputArguments) {\n    logger.info { \"Skipping stacktrace-decoroutinator as enhanced hotswap is active\" }\n} else if (\"--no-decoroutinator\" in args) {\n    logger.info { \"Skipping stacktrace-decoroutinator as --no-decoroutinator is specified\" }\n} else {\n    DecoroutinatorRuntime.load()\n}\n</code></pre> <p>Warning</p> <p><code>stacktrace-decoroutinator</code> must be loaded before any coroutine code is loaded,  including suspending main functions <code>suspend fun main() { ... }</code>.</p> <pre><code>// stacktrace-decoroutinator has issues when reloading with hotswap agent\nif (ManagementFactory.getRuntimeMXBean().getInputArguments().contains(\"-XX:+AllowEnhancedClassRedefinition\")) {\n    logger.info(\"Skipping stacktrace-decoroutinator as enhanced hotswap is active\");\n} else if (Arrays.asList(args).contains(\"--no-decoroutinator\")) {\n    logger.info(\"Skipping stacktrace-decoroutinator as --no-decoroutinator is specified\");\n} else {\n    DecoroutinatorRuntime.INSTANCE.load();\n}\n</code></pre>"},{"location":"setup/getting-started/#creating-a-runnable-jar","title":"Creating a runnable JAR","text":"MavenKotlin Gradle <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;\n    &lt;version&gt;3.5.0&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;phase&gt;package&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;shade&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;configuration&gt;\n                &lt;transformers&gt;\n                    &lt;transformer\n                            implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt;\n                        &lt;mainClass&gt;io.github.name.bot.Main&lt;/mainClass&gt; &lt;!-- TODO change here --&gt;\n                    &lt;/transformer&gt;\n                    &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"/&gt;\n                &lt;/transformers&gt;\n\n                &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;\n                &lt;finalName&gt;${artifactId}&lt;/finalName&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre> <pre><code>plugins {\n    ...\n    id(\"com.github.johnrengelman.shadow\") version \"7.1.2\"\n}\n\napplication.mainClass.set(\"io.github.name.bot.Main\")    //TODO change here\n\ntasks.withType&lt;ShadowJar&gt; {\n    mergeServiceFiles() // Fixes Java's service loading, which is used by Flyway\n    archiveFileName.set(\"your-project-name.jar\")        //TODO change here\n}\n</code></pre> <p>While you can run the main class in your IDE during development, you can create a JAR with all the dependencies by pressing Ctrl twice in IntelliJ, then running:</p> MavenKotlin Gradle <pre><code>mvn package\n</code></pre> <pre><code>gradle shadowJar\n</code></pre>"},{"location":"setup/getting-started/#other-resources","title":"Other resources","text":"<p>Take a look at other wiki pages, such as Dependency injection,  Creating slash command and Using components.</p>"},{"location":"setup/getting-started/#examples","title":"Examples","text":"<p>You can find examples covering parts of the framework here.</p>"},{"location":"setup/getting-started/#getting-help","title":"Getting help","text":"<p>Don't hesitate to join the support server if you have any question!</p>"},{"location":"setup/logging/","title":"Logging","text":"<p>Add a logger with the following dependencies:</p> <p> </p> MavenKotlin Gradle <pre><code>&lt;dependencies&gt;\n    ...\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n        &lt;version&gt;SLF4J_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n        &lt;version&gt;LOGBACK_VERSION&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>repositories {\n    ...\n    mavenCentral()\n}\n\ndependencies {\n    ...\n\n    implementation(\"org.slf4j:slf4j-api:SLF4J_VERSION\")\n    implementation(\"ch.qos.logback:logback-classic:LOGBACK_VERSION\")\n}\n</code></pre> <p>Here are the logback configs I recommend using:</p> Dev configProd config <p>I would recommend putting it in your project, in a folder containing your config files, and load it as such:</p> <p>Danger</p> <p>Just like any sensitive data, make sure to add the folder to your .gitignore,  as it will contain much more than just the logback config.</p> <p>However, you can provide a template for contributors/other users.</p> KotlinJava <pre><code>System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, PATH_TO_LOGBACK.absolutePathString())\n</code></pre> <pre><code>System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, PATH_TO_LOGBACK.toAbsolutePath().toString());\n</code></pre> logback-test.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration scan=\"true\"&gt; &lt;!-- Reloads every minute --&gt;\n    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} %boldCyan(%-26.-26thread) %boldYellow(%-20.-20logger{0}) %highlight(%-6level) %msg%n%throwable&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- JDA --&gt;\n    &lt;logger name=\"net.dv8tion.jda\" level=\"info\"/&gt;\n\n    &lt;!-- HikariCP --&gt;\n    &lt;logger name=\"com.zaxxer.hikari\" level=\"info\"/&gt;\n\n    &lt;!-- Flyway --&gt;\n    &lt;logger name=\"org.flywaydb\" level=\"warn\"/&gt;\n\n    &lt;!-- BotCommands --&gt;\n    &lt;logger name=\"io.github.freya022.botcommands\" level=\"debug\"/&gt;\n\n    &lt;!-- Other logs --&gt;\n    &lt;root level=\"info\"&gt;\n        &lt;appender-ref ref=\"STDOUT\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <p>I would recommend putting it in a folder next to the bot's JAR, and load it as such:</p> KotlinJava <pre><code>System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, PATH_TO_LOGBACK.absolutePathString())\n</code></pre> <pre><code>System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, PATH_TO_LOGBACK.toAbsolutePath().toString());\n</code></pre> logback.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration scan=\"true\"&gt; &lt;!-- Reloads every minute --&gt;\n    &lt;timestamp key=\"bySecond\" datePattern=\"yyyyMMdd'T'HHmmss\"/&gt;\n\n    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} %boldCyan(%-26.-26thread) %boldYellow(%-20.-20logger{0}) %highlight(%-6level) %msg%n%throwable&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n        &lt;file&gt;logs/latest.log&lt;/file&gt;\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;\n            &lt;!-- daily rollover --&gt;\n            &lt;fileNamePattern&gt;logs/logs-%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;\n\n            &lt;!-- keep 90 days worth of history capped at 3GB total size --&gt;\n            &lt;maxHistory&gt;90&lt;/maxHistory&gt;\n            &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;\n        &lt;/rollingPolicy&gt;\n\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} %-26.-26thread %-36.-36class{36} #%-24.-24method{24} L%-5.-5line %-20.-20logger{0} %-6level %msg%n%throwable&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- JDA --&gt;\n    &lt;logger name=\"net.dv8tion.jda\" level=\"info\"/&gt;\n\n    &lt;!-- HikariCP --&gt;\n    &lt;logger name=\"com.zaxxer.hikari\" level=\"info\"/&gt;\n\n    &lt;!-- Flyway --&gt;\n    &lt;logger name=\"org.flywaydb\" level=\"info\"/&gt;\n\n    &lt;!-- BotCommands --&gt;\n    &lt;logger name=\"io.github.freya022.botcommands\" level=\"debug\"/&gt;\n\n    &lt;!-- Other logs --&gt;\n    &lt;root level=\"info\"&gt;\n        &lt;appender-ref ref=\"STDOUT\"/&gt;\n        &lt;appender-ref ref=\"FILE\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"using-botcommands/database/","title":"Using a database","text":"<p>The framework provides several JDBC abstractions, statement logging, reporting long transactions and officially supports PostgreSQL and H2 (in PostgreSQL compatibility mode).</p> <p>Info</p> <p>Some features requires a database, such as components and paginators.</p>"},{"location":"using-botcommands/database/#creating-a-connectionsupplier","title":"Creating a <code>ConnectionSupplier</code>","text":"<p>A <code>ConnectionSupplier</code> is responsible for providing connections to your database, as well as some metadata.</p> <p>Requesting the connection supplier service is not recommended, you should instead use <code>Database</code> (Kotlin) and <code>BlockingDatabase</code> (Java).</p> <p>If you wish not to use these abstractions, you can use their <code>fetchConnection</code> methods, to at least take advantage of statement logging and long transaction reports.</p> <p>We'll also use HikariCP, a connection pool that will reduce latency a lot when often reacquiring connections.</p> <p>Creating a datasource requires implementing <code>HikariSourceSupplier</code>, where you can directly give the connection details, that's it.</p> Example PostgreSQLH2 KotlinJava <pre><code>@BService\nclass DatabaseSource(config: Config) : HikariSourceSupplier {\n    override val source = HikariDataSource(HikariConfig().apply {\n        // Suppose those are your config values\n        jdbcUrl = config.databaseConfig.url\n        username = config.databaseConfig.user\n        password = config.databaseConfig.password\n\n        // At most 2 JDBC connections, suspends the coroutine if all connections are used\n        maximumPoolSize = 2\n        // Emits a warning and does a thread/coroutine dump after the duration\n        leakDetectionThreshold = 10.seconds.inWholeMilliseconds\n    })\n}\n</code></pre> <pre><code>@BService\npublic class DatabaseSource implements HikariSourceSupplier {\n    private final HikariDataSource source;\n\n    public DatabaseSource(Config config) {\n        final var hikariConfig = new HikariConfig();\n        // Suppose those are your config values\n        hikariConfig.setJdbcUrl(config.getDatabaseConfig().getUrl());\n        hikariConfig.setUsername(config.getDatabaseConfig().getUser());\n        hikariConfig.setPassword(config.getDatabaseConfig().getPassword());\n\n        // At most 2 JDBC connections, the database will block if all connections are used\n        hikariConfig.setMaximumPoolSize(2);\n\n        // Emits a warning and does a thread/coroutine dump after the duration (in milliseconds)\n        hikariConfig.setLeakDetectionThreshold(10000);\n\n        source = new HikariDataSource(hikariConfig);\n    }\n\n    @NotNull\n    @Override\n    public HikariDataSource getSource() {\n        return source;\n    }\n}\n</code></pre> <p>PostgreSQL connection URL</p> <p>The URL should be similar to <code>jdbc:postgresql://[HOST]:[PORT]/[DB_NAME]</code>, by default, the port is 5432.</p> KotlinJava <pre><code>@BService\nclass DatabaseSource : HikariSourceSupplier {\n    override val source = HikariDataSource(HikariConfig().apply {\n        // Create an in-file database with the PostgreSQL compatibility mode\n        jdbcUrl = \"jdbc:h2:./MyBotDatabase;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH\"\n\n        // At most 2 JDBC connections, suspends the coroutine if all connections are used\n        maximumPoolSize = 2\n        // Emits a warning and does a thread/coroutine dump after the duration\n        leakDetectionThreshold = 10.seconds.inWholeMilliseconds\n    })\n}\n</code></pre> <pre><code>@BService\npublic class DatabaseSource implements HikariSourceSupplier {\n    private final HikariDataSource source;\n\n    public DatabaseSource() {\n        final var hikariConfig = new HikariConfig();\n        // Create an in-file database with the PostgreSQL compatibility mode\n        hikariConfig.setJdbcUrl(\"jdbc:h2:./MyBotDatabase;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH\");\n\n        // At most 2 JDBC connections, the database will block if all connections are used\n        hikariConfig.setMaximumPoolSize(2);\n\n        // Emits a warning and does a thread/coroutine dump after the duration (in milliseconds)\n        hikariConfig.setLeakDetectionThreshold(10000);\n\n        source = new HikariDataSource(hikariConfig);\n    }\n\n    @NotNull\n    @Override\n    public HikariDataSource getSource() {\n        return source;\n    }\n}\n</code></pre> <p>This will create a database stored in a file called <code>MyBotDatabase</code>, in the current working directory, see more details on the H2 website.</p>"},{"location":"using-botcommands/database/#using-migration","title":"Using migration","text":"<p>The framework's tables may be automatically created and migrated on updates, while the migration scripts uses a naming scheme compatible with Flyway, it may work with other migration libraries.</p> <p>Using <code>ServiceLoader</code>-based libraries</p> <p>Libraries like Flyway, PostgreSQL and SLF4J, uses a <code>ServiceLoader</code> which requires having files in your JAR to load these services.</p> <p>While creating your JAR, your build tools needs to be configured to merge those files properly, as it would overwrite those files when multiple libraries target a common interface, causing missing services.</p> <p>You can see how it's done in this Setup section.</p> <p>Migration using Flyway</p> <p>You can run this after creating your database:</p> <pre><code>Flyway.configure()\n    .dataSource(source) // Your already existing data source\n    .schemas(\"bc\") // The name of the internal schema\n    .locations(\"bc_database_scripts\") // Where the migration scripts are located\n    .validateMigrationNaming(true)\n    .loggers(\"slf4j\") // Both JDA and BC logs using SLF4J\n    .load()\n    .migrate() // Create or update existing schema\n</code></pre> <p>Tip</p> <p>You can also use the same code to migrate your own database, using similar migration scripts.</p>"},{"location":"using-botcommands/database/#configuration","title":"Configuration","text":""},{"location":"using-botcommands/database/#logging-statements","title":"Logging statements","text":"<p>SQL Statements can be logged if:</p> <ul> <li><code>BDatabaseConfig#logQueries</code> is enabled,   and the logger of the class that created the prepared statement has its <code>TRACE</code> logs enabled</li> <li>Or, <code>BDatabaseConfig#queryLogThreshold</code> is configured,   and the logger of the class that created the prepared statement has its <code>WARN</code> logs enabled</li> </ul> <p>Ignoring utility classes creating prepared statements</p> <p>If you are creating a prepared statement in a class unrelated to what actually uses the statement, the queries will be logged using the unrelated class.</p> <p>The logger used is the first class in the call stack that's not annotated with <code>@IgnoreStackFrame</code>, you may use this annotation on your class, making the logger use the caller class.</p> <p>You can alternatively use <code>withLogger</code> to manually set the logger of a prepared statement.</p>"},{"location":"using-botcommands/database/#report-long-transactions","title":"Report long transactions","text":"<p>A thread/coroutine dump can be created when the connection has a longer lifetime than expected, refer to <code>BDatabaseConfig#dumpLongTransactions</code> for more details.</p>"},{"location":"using-botcommands/database/#sample-usages","title":"Sample usages","text":""},{"location":"using-botcommands/database/#running-a-statement-returning-a-value","title":"Running a statement, returning a value","text":"KotlinJava <pre><code>        val tagCount: Long = database.preparedStatement(\"SELECT count(*) FROM tag\") {\n            val dbResult = executeQuery().read() //Read a single row\n            dbResult[1] // Indexes start at 1\n        }\n</code></pre> <pre><code>        final long tagCount = database.withStatement(\"SELECT count(*) FROM tag\", statement -&gt; {\n            return statement.executeQuery().read() //Read a single row\n                    .getLong(1); // Indexes start at 1\n        });\n</code></pre>"},{"location":"using-botcommands/database/#running-a-statement-returning-rows","title":"Running a statement, returning rows","text":"KotlinJava <pre><code>        val tagNames: List&lt;String&gt; = database.preparedStatement(\"SELECT name FROM tag\") {\n            // Reads all rows and convert them to strings (type inference with List&lt;String&gt;)\n            executeQuery().map { it[\"name\"] }\n        }\n</code></pre> <pre><code>        final List&lt;String&gt; tagNames = database.withStatement(\"SELECT name FROM tag\", statement -&gt; {\n            // Reads all rows and convert them to strings\n            return statement.executeQuery()\n                    .stream()\n                    .map(result -&gt; result.getString(\"name\"))\n                    .toList();\n        });\n</code></pre>"},{"location":"using-botcommands/database/#running-multiple-statements-in-a-transaction-statement","title":"Running multiple statements in a transaction statement","text":"KotlinJava <pre><code>            database.transactional {\n                // This should not be in the database since the next query will fail, thus reverting the transaction\n                preparedStatement(\"INSERT INTO tag (name, content) VALUES ('should_not_be_here', 'should not be here')\") {\n                    executeUpdate()\n                }\n                // This will raise an exception as the name has a constraint matching ^[\\w-]+$ (spaces aren't allowed, for example)\n                preparedStatement(\"INSERT INTO tag (name, content) VALUES ('invalid name', 'foo')\") {\n                    executeUpdate()\n                }\n            }\n</code></pre> <pre><code>            database.withTransaction(transaction -&gt; {\n                // This should not be in the database since the next query will fail, thus reverting the transaction\n                transaction.withStatement(\"INSERT INTO tag (name, content) VALUES ('should_not_be_here', 'should not be here')\", statement -&gt; {\n                    statement.executeUpdate();\n                    return null;\n                });\n                // This will raise an exception as the name has a constraint matching ^[\\w-]+$ (spaces aren't allowed, for example)\n                transaction.withStatement(\"INSERT INTO tag (name, content) VALUES ('invalid name', 'foo')\", statement -&gt; {\n                    statement.executeUpdate();\n                    return null;\n                });\n                return null;\n            });\n</code></pre>"},{"location":"using-botcommands/database/#running-a-single-statement-returning-generated-keys","title":"Running a single statement, returning generated keys","text":"KotlinJava <pre><code>        val createdAt: Instant = database.preparedStatement(\n            \"INSERT INTO tag (name, content) VALUES ('new_tag', 'new content')\",\n            columnNames = arrayOf(\"created_at\") // This is required as this is a generated column\n        ) {\n            executeReturningUpdate() // executeUpdate() + getGeneratedKeys()\n                .read() //Read a single row\n                .getTimestamp(\"created_at\").toInstant()\n        }\n</code></pre> <pre><code>        final Instant createdAt = database.withStatement(\n                \"INSERT INTO tag (name, content) VALUES ('new_tag', 'new content')\",\n                new String[]{\"created_at\"}, // This is required as this is a generated column\n                statement -&gt; {\n                    return statement.executeReturningUpdate() // executeUpdate() + getGeneratedKeys()\n                            .read() //Read a single row\n                            .getTimestamp(\"created_at\").toInstant();\n                });\n</code></pre>"},{"location":"using-botcommands/extensions/","title":"Kotlin extensions","text":"<p>In addition to what JDA-KTX offers, Kotlin users have access to top-level functions and extensions in various categories:</p>"},{"location":"using-botcommands/extensions/#jda","title":"JDA","text":""},{"location":"using-botcommands/extensions/#rest-actions","title":"REST actions","text":"<code>awaitUnit</code> - Awaits completion and returns <code>Unit</code>, particularly useful to reply + return <pre><code>fun onSlashCommand(event: GuildSlashEvent, inputUser: InputUser)\n    val member = inputUser.member\n        ?: return event.reply_(\"The user needs to be a member of this server!\", ephemeral = true).awaitUnit()\n}\n</code></pre> <code>awaitOrNullOn</code> - Awaits completion, returns <code>null</code> if the action failed with the expected error response <pre><code>fun onSlashBanInfo(event: GuildSlashEvent, user: User)\n    val ban = event.guild.retrieveBan(user).awaitOrNullOn(ErrorResponse.UNKNOWN_BAN)\n        ?: return event.reply_(\"This user is not banned\", ephemeral = true).awaitUnit()\n}\n</code></pre> <code>awaitCatching</code> - Awaits completion and returns a <code>Result</code> with the wrapped value/failure <pre><code>fun onSlashBanInfo(event: GuildSlashEvent, user: User)\n    val ban = event.guild.retrieveBan(user).awaitCatching()\n        .onErrorResponse(ErrorResponse.UNKNOWN_BAN) {\n            return event.reply_(\"This user is not banned\", ephemeral = true).awaitUnit()\n        }\n        .getOrThrow()\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#error-response-handling","title":"Error response handling","text":"<ul> <li><code>onErrorResponse</code> - See <code>awaitCatching</code></li> <li><code>Result&lt;Unit&gt;.ignore</code> - Ignores and clears the specified error responses</li> <li><code>Result&lt;T&gt;.handle</code> - Supplies a value when the specified error response is caught</li> </ul> <code>runIgnoringResponse</code> - Runs the block and ignores the following error responses, throws other exceptions <pre><code>runIgnoringResponse(ErrorResponse.CANNOT_SEND_TO_USER) {\n    channel.sendMessage(msg).await()\n}\n</code></pre> <code>runIgnoringResponseOrNull</code> - Runs the block and returns <code>null</code> on the following error responses, throws other exceptions <pre><code>suspend fun Guild.retrieveBanOrNull(user: UserSnowflake): Ban? = runIgnoringResponseOrNull(ErrorResponse.UNKNOWN_BAN) {\n    retrieveBan(user).await() // Can also use awaitOrNullOn, removing runIgnoringResponseOrNull\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#messages","title":"Messages","text":"<ul> <li><code>MessageCreateData.toEditData</code> - Does what it says, the edit data will replace the content of the entire message</li> <li> <p><code>MessageEditData.toCreateData</code> - Do I need to say anything?</p> </li> <li> <p><code>MessageCreateData.send</code> - Sends the message, this is useful for chaining</p> </li> <li><code>MessageEditData.edit</code> - Edits with that message, this is useful for chaining</li> <li> <p><code>InteractionHook.replaceWith</code> - Replaces this interaction's message with the following content</p> </li> <li> <p><code>RestAction&lt;R&gt;.deleteDelayed</code> - Deletes the message after the delay, the rest action itself is delayed, not the code execution</p> </li> </ul>"},{"location":"using-botcommands/extensions/#entity-retrieval","title":"Entity retrieval","text":"<p>Those check the cache before doing a request.</p> <ul> <li><code>Guild.retrieveMemberOrNull</code> - Returns null if the member does not exist</li> <li><code>JDA.retrieveUserOrNull</code> - Returns null if the user does not exist</li> <li><code>Guild.retrieveThreadChannelById</code> - Retrieves a thread by ID, from any thread container, archived or not.</li> <li><code>Guild.retrieveThreadChannelOrNull</code> - Same but returns null if it does not exist, if the bot doesn't have access to it, or if the channel isn't a thread.</li> </ul>"},{"location":"using-botcommands/extensions/#misc","title":"Misc","text":"<code>suppressContentWarning</code> - Runs the block and suppresses warnings emitted by JDA when reading message content, this is mostly useful in message context commands <pre><code>val contentRaw = suppressContentWarning { message.contentRaw }\n</code></pre> <ul> <li><code>getMissingPermissions</code> - Gets the missing permissions from the required permissions, for the given entity, in the specified channel</li> </ul> <p>Any method accepting a Java <code>Duration</code> should also have an extension using Kotlin's <code>Duration</code></p>"},{"location":"using-botcommands/extensions/#resolvers","title":"Resolvers","text":"<code>enumResolver</code> - Creates a parameter resolver which transforms arguments into an enum entry, compatible with most handlers <pre><code>enum class MyEnum {\n    FIRST,\n    SECOND,\n    THIRD\n}\n\n@BConfiguration\nclass MyEnumResolverProvider {\n    // Creates an enum resolver for all values\n    // you can also customize what values can be used, per-guild,\n    // and also change how they are displayed\n    @Resolver\n    fun myEnumResolver() = enumResolver&lt;MyEnum&gt;()\n}\n</code></pre> <code>resolverFactory</code> - Creates a factory for parameter resolvers, useful to avoid the boilerplate of using <code>TypedParameterResolverFactory</code> <p>See example on the docs</p>"},{"location":"using-botcommands/extensions/#io","title":"I/O","text":"<code>readResource</code> - Gets an <code>InputStream</code> of a resource from the classpath <pre><code>readResource(\"/file.txt\").use { contentStream -&gt;\n    // ...\n}\n</code></pre> <code>readResourceAsString</code> - Gets a resource from the classpath as a <code>String</code> <pre><code>val content = readResourceAsString(\"/file.txt\")\n</code></pre> <code>withResource</code> - Uses an <code>InputStream</code> of a resource from the classpath <pre><code>withResource(\"/file.txt\") { contentStream -&gt;\n    // ...\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#coroutines","title":"Coroutines","text":"<code>namedDefaultScope</code> - Creates a <code>CoroutineScope</code> with a thread name and a fixed thread pool <pre><code>// 1 thread named \"[feature] timeout\"\n// You can also configure other CoroutineScope characteristics\nprivate val timeoutScope = namedDefaultScope(\"[feature] timeout\", corePoolSize = 1)\n\n// ...\n\ntimeoutScope.launch {\n    // Async task\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#logging","title":"Logging","text":"<code>KotlinLogging.loggerOf</code> - Creates a logger targeting the specified class <pre><code>private val logger = KotlinLogging.loggerOf&lt;MyService&gt;()\n\n@BService\nclass MyServiceImpl : MyService {\n    // ...\n}\n</code></pre>"},{"location":"using-botcommands/extensions/#collections","title":"Collections","text":"<ul> <li><code>enumSetOf</code> - Creates an enum set of the provided type</li> <li><code>enumSetOfAll</code> - Creates an enum set of the provided type, with all the entries in it</li> <li><code>enumMapOf</code> - Creates a map with an enum key</li> <li><code>toImmutableList</code> - Creates an immutable copy of the list</li> <li><code>toImmutableSet</code> - Creates an immutable copy of the set</li> <li><code>toImmutableMap</code> - Creates an immutable copy of the map</li> <li><code>containsAny</code> - Checks if the collection contains any of the provided elements</li> </ul>"},{"location":"using-botcommands/parameter-names/","title":"Enabling Java parameter names","text":"<p>Tip</p> <p>This is NOT required if you are using Kotlin.</p> <p>A significant part of the framework benefits from having accessible method parameter names,  such as <code>@TextOption</code> or <code>@SlashOption</code>, injecting a service by its name,  including better debugging / error messages.</p> MavenGradle <p>You can add the necessary compiler argument in the configuration for the Maven compiler plugin: pom.xml<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;version&gt;${compiler.plugin.version}&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;!-- ... --&gt;\n        &lt;compilerArgs&gt;\n            &lt;compilerArg&gt;-parameters&lt;/compilerArg&gt;\n        &lt;/compilerArgs&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre></p> <p>You can add the necessary compiler argument to the Java compile options: build.gradle.kts<pre><code>tasks.withType&lt;JavaCompile&gt; {\n    options.compilerArgs += \"-parameters\"\n}\n</code></pre></p>"},{"location":"using-botcommands/dependency-injection/","title":"Dependency injection","text":"<p>Dependency injection provided by this framework is a more lightweight alternative to dedicated frameworks, quite similarly to Spring (which is supported)  or CDI using Weld.</p> <p>Rather than you having to construct objects, you may only request them, the framework will then construct it by providing the dependencies required for your service, wherever they may come from.</p> <p>This avoids having to pass objects everywhere, allowing a more effective decoupling, and allows switching implementations in a completely transparent manner.</p> <p>Example</p> <p><code>ConnectionSupplier</code> is an interfaced service (an interface that, when implemented, enables the service to be retrieved as such interface).</p> <p>You can create an implementation of this interface, per database, enabling you to switch your database,  for example, using a configuration file, without changing anything else in your code.</p> 2.X Migration <p>All singletons / classes with static methods were moved as services, including:</p> <ul> <li><code>Components</code></li> <li><code>EventWaiter</code></li> <li><code>Localization</code></li> </ul> <p>If you were using <code>ExtensionsBuilder#registerConstructorParameter(Class&lt;T&gt;, ConstructorParameterSupplier&lt;T&gt;)</code> to get objects in commands,  it is basically the same, except in a much more complete framework, and without having to declare everything with this method.</p> 2.X3.X JavaKotlin TagDatabase.java<pre><code>public class TagDatabase { /* */ }\n</code></pre> TagCommand.java<pre><code>public class TagCommand {\n    private final TagDatabase tagDatabase;\n\n    public TagCommand(TagDatabase tagDatabase) {\n        this.tagDatabase = tagDatabase;\n    }\n}\n</code></pre> Builder<pre><code>final var tagDatabase = new TagDatabase(/* */);\n\nCommandsBuilder.newBuilder()\n    .registerConstructorParameter(TagDatabase.class, clazz -&gt; tagDatabase)\n    // Further configuration\n    .build();\n</code></pre> TagDatabase.kt<pre><code>class TagDatabase { /* */ }\n</code></pre> TagCommand.kt<pre><code>class TagCommand(private val tagDatabase: TagDatabase) {\n    /* */\n}\n</code></pre> Builder<pre><code>val tagDatabase = TagDatabase(/* */);\n\nCommandsBuilder.newBuilder()\n    .registerConstructorParameter(TagDatabase::class.java) { tagDatabase }\n    // Further configuration\n    .build();\n</code></pre> JavaKotlin TagDatabase.java<pre><code>@BService //Makes this class injectable, can also pull other services in its constructor\npublic class TagDatabase { /* */ }\n</code></pre> TagCommand.java<pre><code>@Command\npublic class TagCommand {\n    private final TagDatabase tagDatabase;\n\n    public TagCommand(TagDatabase tagDatabase) {\n        this.tagDatabase = tagDatabase;\n    }\n\n    /* */\n}\n</code></pre> <p>No specific builder code required!</p> TagDatabase.kt<pre><code>@BService //Makes this class injectable, can also pull other services in its constructor\nclass TagDatabase { /* */ }\n</code></pre> TagCommand.kt<pre><code>@Command\nclass TagCommand(private val tagDatabase: TagDatabase) {\n    /* */\n}\n</code></pre> <p>No specific builder code required!</p>"},{"location":"using-botcommands/dependency-injection/creating-services/","title":"Creating services","text":"<p>To register a class as a service, add <code>@BService</code> to your class declaration.</p> <p><code>@BService</code> is the base annotation to register a service,  other annotations exist such as <code>@Command</code> and <code>@Resolver</code>,  but the appropriate documentation will specify if such alternatives are required.</p> <p>Info</p> <p>All classes available for dependency injection must be in the framework's classpath, by adding packages to <code>BConfigBuilder#packages</code>, or by using <code>BConfigBuilder#addSearchPath</code>,  all classes are searched recursively.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-factories","title":"Service factories","text":"<p>Service factories are methods that create initialized services themselves, they accept other services as parameters and define a service with the method's return type.</p> <p>In addition to the package requirement, they must be annotated with <code>@BService</code>, be in a service, or in an <code>object</code>, or be a static method.</p> <p>Terminology</p> <p>Classes registered as services, and service factories, are service providers.</p> Example JavaKotlinKotlin property <pre><code>public class Config {\n    private static Config INSTANCE = null;\n\n    /* */\n\n    // Service factory, registers as \"Config\" (as it is the return type), with the name \"config\"\n    // You can use any method name, but the method name is what the service is registered as\n    @BService\n    public static Config config() {\n        if (INSTANCE == null) {\n            // Of course here you would load the config from a file\n            INSTANCE = new Config();\n        }\n\n        return INSTANCE;\n    }\n}\n</code></pre> <pre><code>class Config {\n    /* */\n\n    companion object {\n        // Service factory, registers as Config (as it is the return type), with the name \"config\"\n        // You can use any method name, but the method name is what the service is registered as\n        @BService\n        fun config(): Config {\n            // Of course here you would load the config from a file\n            Config()\n        }\n    }\n}\n</code></pre> <pre><code>class Config {\n    /* */\n\n    companion object {\n        // Service factory, registers as Config (as it is the return type), with the name \"config\"\n        @get:BService\n        val config: Config by lazy {\n            // Of course here you would load the config from a file\n            Config()\n        }\n    }\n}\n</code></pre> <p>Tip</p> <p>To suppress unused warnings on the declaring class, you can use <code>@BConfiguration</code>, unless the declaring class itself must be a service.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#conditional-services","title":"Conditional services","text":"<p>Warning</p> <p>This section only applies to the built-in dependency injection</p> <p>Some services may not always be instantiable,  some may require soft dependencies (prevents instantiation if a service is unavailable, without failing), while some run a set of conditions to determine if a service can be instantiated.</p> <p>Services that are not instantiable will not be created at startup,  will be unavailable for injection and do not figure in the list of interfaced services.</p> <p>Info</p> <p>All the following annotations must be used alongside a service-declaring annotation,  such as <code>@BService</code> or <code>@Command</code>.</p> <p>Tip</p> <p>There is a few built-in conditional annotations, such as:</p> <ul> <li><code>@RequiredIntents</code>: Enables a service if the <code>JDAService</code> has the specified intents enabled.</li> <li><code>@RequiresDatabase</code>: Enables a service if a <code>(Blocking)Database</code> instance is available.</li> <li><code>@RequiresComponents</code>: Enables a service if components are enabled.</li> </ul>"},{"location":"using-botcommands/dependency-injection/creating-services/#dependencies","title":"Dependencies","text":"<p>The <code>@Dependencies</code> annotation lets you define soft dependencies, that is, if any of these classes in the annotation are unavailable, your service will not be instantiated.</p> <p>Without the annotation, any unavailable dependency would throw an exception.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#interfaced-conditions","title":"Interfaced conditions","text":"<p><code>@ConditionalService</code> defines a list of classes implementing <code>ConditionalServiceChecker</code>, the service is only created if none of these classes return an error message.</p> <p><code>ConditionalServiceChecker</code> can be implemented on any class that has a no-arg constructor, or is an <code>object</code>.</p> Example JavaKotlin <pre><code>@Command\n@ConditionalService(TagCommand.FeatureCheck.class) // Only create the command if this passes\npublic class TagCommand {\n    /* */\n\n    public static class FeatureCheck implements ConditionalServiceChecker {\n        @Nullable\n        @Override\n        public String checkServiceAvailability(@NotNull ServiceContainer serviceContainer, @NotNull Class&lt;?&gt; checkedClass) {\n            final var config = serviceContainer.getService(Config.class); // Suppose this is your configuration\n            if (!config.areTagsEnabled()) {\n                return \"Tags are disabled in the configuration\"; // Do not allow the tag command!\n            }\n            return null; // No error message, allow the tag command!\n        }\n    }\n}\n</code></pre> <pre><code>@Command\n@ConditionalService(TagCommand.FeatureCheck::class) // Only create the command if this passes\nclass TagCommand {\n    /* */\n\n    object FeatureCheck : ConditionalServiceChecker {\n        override fun checkServiceAvailability(serviceContainer: ServiceContainer, checkedClass: Class&lt;*&gt;): String? {\n            val config = serviceContainer.getService&lt;Config&gt;() // Suppose this is your configuration\n            if (!config.enableTags) {\n                return \"Tags are disabled in the configuration\" // Do not allow the tag command!\n            }\n            return null // No error message, allow the tag command!\n        }\n    }\n}\n</code></pre>"},{"location":"using-botcommands/dependency-injection/creating-services/#annotation-conditions","title":"Annotation conditions","text":"<p><code>@Condition</code> is a meta-annotation (an annotation for annotations) which marks your own annotation as being a condition.</p> <p>Similar to interfaced conditions, they must refer to an implementation of <code>CustomConditionChecker</code>,  to determine if the annotated service can be created,  you can also indicate if the service creation must throw an exception in case it fails.</p> <p>The implementation must have a no-arg constructor, or be an <code>object</code></p> <p>Note</p> <p>The annotation must also be in the framework's classpath.</p> Example JavaKotlin DevCommand.java<pre><code>// Same targets as service annotations\n@Target({ElementType.TYPE, ElementType.METHOD})\n// The implementation of our CustomConditionChecker\n@Condition(type = DevCommandChecker.class)\npublic @interface DevCommand { }\n</code></pre> DevCommandChecker.java<pre><code>// Checks services annotated with @DevCommand\npublic class DevCommandChecker implements CustomConditionChecker&lt;DevCommand&gt; {\n    @NotNull\n    @Override\n    public Class&lt;DevCommand&gt; getAnnotationType() {\n        return DevCommand.class;\n    }\n\n    @Nullable\n    @Override\n    public String checkServiceAvailability(@NotNull ServiceContainer serviceContainer, @NotNull Class&lt;?&gt; checkedClass, @NotNull DevCommand annotation) {\n        final var config = serviceContainer.getService(Config.class); // Suppose this is your configuration\n        if (!config.isDevModeEnabled()) {\n            return \"Dev mode is disable in the configuration\"; // Do not allow the dev commands!\n        }\n        return null; // No error message, allow the tag command!\n    }\n}\n</code></pre> SlashShutdown.java<pre><code>@Command\n@DevCommand // Our custom condition, this command will only exist if it passes.\npublic class SlashShutdown {\n    /* */\n}\n</code></pre> DevCommand.kt<pre><code>// Same targets as service annotations\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER)\n// The implementation of our CustomConditionChecker\n@Condition(type = DevCommandChecker::class)\nannotation class DevCommand\n\n// Checks services annotated with @DevCommand\nobject DevCommandChecker : CustomConditionChecker&lt;DevCommand&gt; {\n    override val annotationType: Class&lt;DevCommand&gt; = DevCommand::class.java\n\n    override fun checkServiceAvailability(serviceContainer: ServiceContainer, checkedClass: Class&lt;*&gt;, annotation: DevCommand): String? {\n        val config = serviceContainer.getService&lt;Config&gt;() // Suppose this is your configuration\n        if (!config.enableDevMode) {\n            return \"Dev mode is disable in the configuration\" // Do not allow the dev commands!\n        }\n        return null // No error message, allow the tag command!\n    }\n}\n</code></pre> SlashShutdown.kt<pre><code>@Command\n@DevCommand // Our custom condition, this command will only exist if it passes.\nclass SlashShutdown {\n    /* */\n}\n</code></pre>"},{"location":"using-botcommands/dependency-injection/creating-services/#interfaced-services","title":"Interfaced services","text":"<p>Warning</p> <p>This section only applies to the built-in dependency injection</p> <p>Interfaced services are interfaces, or abstract class, marked by <code>@InterfacedService</code>, they must be implemented by a service.</p> <p>In addition to the service's type, implementations of these annotated interfaces have the interface's type automatically added.</p> <p>Some interfaced services may only be implemented once, some may allow multiple implementations, if an interfaced service only accepts one implementation, multiple implementations can exist, but only one must be instantiable.</p> <p>Creating multiple interfaced services in one</p> <p>You can implement multiple interfaced services at once,  which may be useful for text, application and component filters.</p> <p>Creating interfaced services without registering the interface type</p> <p>You can also implement an interfaced service, without it being accessible as such,  by using <code>@IgnoreServiceTypes</code>.</p> 2.X Migration <p>Most methods in <code>CommandsBuilder</code> accepting interfaces, implementations or lambdas, were moved to interfaced services:</p> <p>Global:</p> <ul> <li><code>CommandsBuilder#setComponentManager</code>: Removed, using components must be enabled in <code>BComponentsConfigBuilder#enable</code>, and a <code>ConnectionSupplier</code> service be present</li> <li><code>CommandsBuilder#setSettingsProvider</code>: Needs to implement <code>SettingsProvider</code></li> <li><code>CommandsBuilder#setUncaughtExceptionHandler</code>: Needs to implement <code>GlobalExceptionHandler</code></li> <li><code>CommandsBuilder#setDefaultEmbedFunction</code>: Needs to implement <code>DefaultEmbedSupplier</code> and <code>DefaultEmbedFooterIconSupplier</code></li> </ul> <p>Text commands:</p> <ul> <li><code>TextCommandBuilder#addTextFilter</code>: Needs to implement <code>TextCommandFilter</code>, and <code>TextCommandRejectionHandler</code></li> <li><code>TextCommandBuilder#setHelpBuilderConsumer</code>: Needs to implement <code>HelpBuilderConsumer</code></li> </ul> <p>Application commands:</p> <ul> <li><code>ApplicationCommandBuilder#addApplicationFilter</code>: Needs to implement <code>ApplicationCommandFilter</code>, and <code>ApplicationCommandRejectionHandler</code></li> <li><code>ApplicationCommandBuilder#addComponentFilter</code>: Needs to implement <code>ComponentCommandFilter</code>, and <code>ComponentCommandRejectionHandler</code></li> </ul> <p>Extensions:</p> <ul> <li><code>ExtensionsBuilder#registerAutocompletionTransformer</code>: Needs to implement <code>AutocompleteTransformer</code></li> <li><code>ExtensionsBuilder#registerCommandDependency</code>: Replaced with standard dependency injection</li> <li><code>ExtensionsBuilder#registerConstructorParameter</code>: Replaced with standard dependency injection</li> <li><code>ExtensionsBuilder#registerCustomResolver</code>: Needs to implement <code>ClassParameterResolver</code> and <code>ICustomResolver</code></li> <li><code>ExtensionsBuilder#registerDynamicInstanceSupplier</code>: Needs to implement <code>DynamicSupplier</code></li> <li><code>ExtensionsBuilder#registerInstanceSupplier</code>: Replaced by service factories</li> <li><code>ExtensionsBuilder#registerParameterResolver</code>: Needs to implement <code>ClassParameterResolver</code> and the resolver interface of your choices</li> </ul>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-properties","title":"Service properties","text":"<p>Warning</p> <p>This section only applies to the built-in dependency injection</p> <p>Service providers can have names, additional registered types, and an instantiation priority.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-names","title":"Service names","text":"<p>Named services may be useful if you have multiple services of the same type, but need to get a specific one.</p> <p>The name is either defined by using <code>@ServiceName</code>, or with <code>BService#name</code> on the service provider.</p> <p>Example</p> <p>You can have a caching <code>HttpClient</code> named <code>cachingHttpClient</code>, while the usual client uses the default name.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-types","title":"Service types","text":"<p>In addition to the type of the service provider,  <code>@ServiceType</code> enables you to register a service as a supertype.</p>"},{"location":"using-botcommands/dependency-injection/creating-services/#service-priority","title":"Service priority","text":"<p>Service priorities control how service providers are sorted.</p> <p>A higher priority means that the service will be loaded first, or that an interfaced service will appear first when requesting interfaced services.</p> <p>The priority is either defined by using <code>@ServicePriority</code>, or with <code>BService#priority</code> on the service provider,  see their documentation to learn what how service providers are sorted.</p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/","title":"Retrieving services","text":"<p>Any class given by a service provider can be injected into other service providers,  requesting a service is as simple as declaring a parameter in the class's constructor,  or the service factory's parameters.</p> <p>Named services can be retrieved by using <code>@ServiceName</code> on the parameter, this can be omitted if the parameter name matches a service with a compatible type.</p> <p>Tip</p> <p>You can also get services manually with <code>BContext</code> or <code>ServiceContainer</code>, the latter has all methods available,  including Kotlin extensions.</p> <p>Example</p> JavaKotlin <pre><code>@BService // Enables the service to request services and be requested\npublic class TagDatabase { /* */ }\n</code></pre> <pre><code>@Command // Enables the command to request services and be requested\npublic class TagCommand {\n    private final Component components;\n    private final TagDatabase tagDatabase;\n\n    public TagCommand(\n        // You can even request framework services, as long as they are annotated with @BService or @InterfacedService\n        Component components,\n        // and your own services\n        TagDatabase tagDatabase\n    ) {\n        this.components = components;\n        this.tagDatabase = tagDatabase;\n    }\n\n    /* */\n}\n</code></pre> <pre><code>@BService // Enables the service to request services and be requested\nclass TagDatabase { /* */ }\n</code></pre> <pre><code>@Command // Enables the command to request services and be requested\nclass TagCommand(\n    // You can even request framework services, as long as they are annotated with @BService or @InterfacedService\n    // Here I've named it \"componentsService\" because \"components\" might conflict with some JDA-KTX builders\n    private val componentsService: Components,\n    // and your own services\n    private val tagDatabase: TagDatabase\n) {\n    /* */\n}\n</code></pre> Retrieving services by name <p>Consider the following service providers:</p> KotlinJava <pre><code>@BService\nclass HttpClientProvider {\n//    @Primary // This is only needed if you try to get an OkHttpClient without matching the name\n    @BService\n    fun httpClient(): OkHttpClient = OkHttpClient()\n\n    @BService\n    fun cachedHttpClient(\n        // Inject the default http client (declared above)\n        // This is not the same as calling the method! as it would create 2 different clients\n\n        // This would not work if the parameter was named differently,\n        // unless @Primary was used on the default declaration above\n        httpClient: OkHttpClient\n    ): OkHttpClient {\n        val tempDirectory = Files.createTempDirectory(null).toFile()\n        return httpClient.newBuilder()\n            .cache(Cache(tempDirectory, maxSize = 1024 * 1024))\n            .build()\n    }\n}\n</code></pre> With <code>@ServiceName</code>With parameter names <pre><code>@BService\nclass MyApi(@ServiceName(\"cachedHttpClient\") httpClient: HttpClient)\n</code></pre> <pre><code>@BService\nclass MyApi(private val cachedHttpClient: HttpClient)\n</code></pre> <pre><code>@BService\npublic class HttpClientProvider {\n//    @Primary // This is only needed if you try to get an OkHttpClient without matching the name\n    @BService\n    public OkHttpClient httpClient() {\n        return new OkHttpClient();\n    }\n\n    @BService\n    public OkHttpClient cachedHttpClient(\n            // Inject the default http client (declared above)\n            // This is not the same as calling the method! as it would create 2 different clients\n\n            // This would not work if the parameter was named differently,\n            // unless @Primary was used on the default declaration above\n            OkHttpClient httpClient\n    ) throws IOException {\n        final File tempDirectory = Files.createTempDirectory(null).toFile();\n        return httpClient.newBuilder()\n                .cache(new Cache(tempDirectory, 1024 * 1024))\n                .build();\n    }\n}\n</code></pre> With <code>@ServiceName</code>With parameter names <pre><code>@BService\npublic class MyApi {\n    public MyApi(@ServiceName(\"cachedHttpClient\") HttpClient httpClient) {\n        // ...\n    }\n}\n</code></pre> <pre><code>@BService\npublic class MyApi {\n    public MyApi(HttpClient cachedHttpClient) {\n        // ...\n    }\n}\n</code></pre> <p>Warning</p> <p>For this to work, you need to enable Java parameter names</p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/#primary-providers","title":"Primary providers","text":"<p>When requesting a service of a specific type/name, there must be at most one usable service provider.</p> <p>For example, if you have two service factories with the same return type:</p> <ul> <li> If both are usable</li> <li> One has a failing condition, meaning you have one usable provider</li> <li> One is annotated with <code>@Primary</code>, in which case this one is prioritized</li> </ul> <p>Note</p> <p>You can still retrieve existing services with <code>ServiceContainer#getInterfacedServices/getInterfacedServiceTypes</code></p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/#interfaced-services","title":"Interfaced services","text":"<p>A list which the element type is an interfaced service can be requested, the list will then contain all instantiable instances with the specified type.</p> <p>Example</p> <p><code>List&lt;ApplicationCommandFilter&lt;?&gt;&gt;</code> will contain all instances implementing <code>ApplicationCommandFilter</code>,  which are usable.</p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/#lazy-services","title":"Lazy services","text":"<p>Lazy service retrieval enables you to get lazily-created service, delaying the initialization, or to get services that are not yet available, such as manually injected services (like <code>JDA</code>).</p> <p>Retrieving a lazy service</p> JavaKotlin <p>Request a <code>Lazy</code> with the element type being the requested service,  and then get the service when needed by using <code>Lazy#getValue</code>.</p> <p>Request a <code>ServiceContainer</code> and use a delegated property, such as:</p> <p><code>private val helpCommand: IHelpCommand by serviceContainer.lazy()</code></p> <p>Note</p> <p>Lazy injections cannot contain a list of interfaced services,  nor can a list of lazy services be requested.</p>"},{"location":"using-botcommands/dependency-injection/retrieving-services/#optional-services","title":"Optional services","text":"<p>When a requested service is not available, and is not a soft-dependency,  service creation will fail.</p> <p>In case your service does not always require the service, you can prevent failure by using Kotlin's nullable / optional parameters, but Java users will need a runtime-retained <code>@Nullable</code> annotation  (such as <code>@javax.annotation.Nullable</code>, or, in checker-framework or JSpecify) or <code>@Optional</code>.</p> <p>Lazy nullability</p> <p>Lazy services can also have their element type be marked as nullable,  for example, <code>Lazy&lt;@Nullable IHelpCommand&gt;</code>.</p>"},{"location":"using-commands/advanced-options/","title":"Advanced options","text":"<p>Text and application command options can benefit from more complex option types,  by combining multiple options into one parameter,  such as varargs, mention strings and custom data structures.</p>"},{"location":"using-commands/advanced-options/#varargs","title":"Varargs","text":"<p>Varargs lets you generate options (up to 25 options per command) and put the values in a <code>List</code>, the number of required options is also configurable.</p>"},{"location":"using-commands/advanced-options/#annotation-declared-commands","title":"Annotation-declared commands","text":"<p>Use <code>@VarArgs</code> on the parameter.</p> <p>The drawback is that each option will be configured the same, name, description, etc...</p>"},{"location":"using-commands/advanced-options/#code-declared-commands","title":"Code-declared commands","text":"<p>Using <code>optionVararg</code> or <code>inlineClassOptionVararg</code> on your command builder lets you solve the above issues.</p> <p>Example</p> <pre><code>fun onSlashCommand(event: GuildSlashEvent, names: List&lt;String&gt;) {\n    // ...    \n}\n</code></pre> <pre><code>manager.slashCommand(\"command\", ::onSlashCommand) {\n    optionVararg(\n        declaredName = \"names\", // Name of the method parameter\n        amount = 5, //How many options to generate\n        requiredAmount = 1, //How many of them are required\n        optionNameSupplier = { num -&gt; \"name_$num\" } // Generate the name of each option\n    ) { num -&gt;\n        // This runs for each option\n        description = \"Name N\u00b0$num\" \n    }\n}\n</code></pre>"},{"location":"using-commands/advanced-options/#mention-strings","title":"Mention strings","text":"<p>You can use this annotation on both code-declared and annotation-declared commands</p> <p><code>@MentionsString</code> is an annotation that lets you retrieve as many mentions as a string option lets you type, you must use it on a <code>List</code> parameter with an element type supported by the annotation.</p> <p>You can also use a <code>List&lt;IMentionable&gt;</code>, where you can set the requested mention types.</p> <p>Note</p> <p>This won't restrict what the user can type on Discord, this only enables parsing mentions inside the string.</p> Bulk ban example KotlinJava <pre><code>@Command\nclass SlashBulkBan : ApplicationCommand() {\n    @JDASlashCommand(name = \"bulk_ban\", description = \"Ban users in bulk\")\n    suspend fun onSlashBulkBan(\n        event: GuildSlashEvent,\n        @SlashOption(description = \"Users to ban\") @MentionsString users: List&lt;InputUser&gt;,\n        @SlashOption(description = \"Time frame of messages to delete\") timeframe: Long,\n        @SlashOption(description = \"Unit of the time frame\", usePredefinedChoices = true) unit: TimeUnit,\n    ) {\n        // Check if any member cannot be banned\n        val higherMembers = users.mapNotNull { it.member }.filterNot { event.guild.selfMember.canInteract(it) }\n        if (higherMembers.isNotEmpty()) {\n            return event.reply_(\"Cannot ban ${higherMembers.joinToString { it.asMention }} as they have equal/higher roles\", ephemeral = true).awaitUnit()\n        }\n\n        event.deferReply(true).queue()\n\n        event.guild.ban(users, timeframe.toDuration(unit.toDurationUnit())).awaitCatching()\n            // Make sure to use onSuccess first,\n            // as 'handle' will clear the result type\n            .onSuccess {\n                event.hook.send(\"Banned ${it.bannedUsers.size} users, ${it.failedUsers.size} failed\").await()\n            }\n            .handle(ErrorResponse.MISSING_PERMISSIONS) {\n                event.hook.send(\"Could not ban users due to missing permissions\").await()\n            }\n            .handle(ErrorResponse.FAILED_TO_BAN_USERS) {\n                event.hook.send(\"Could not ban anyone\").await()\n            }\n            // Throw unhandled exceptions\n            .getOrThrow()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashBulkBan extends ApplicationCommand {\n    @JDASlashCommand(name = \"bulk_ban\", description = \"Ban users in bulk\")\n    public void onSlashBulkBan(\n            GuildSlashEvent event,\n            @SlashOption(description = \"Users to ban\") @MentionsString List&lt;? extends InputUser&gt; users,\n            @SlashOption(description = \"Time frame of messages to delete\") Long timeframe,\n            @SlashOption(description = \"Unit of the time frame\", usePredefinedChoices = true) TimeUnit unit\n    ) {\n        // Check if any member cannot be banned\n        final var higherMembers = new ArrayList&lt;Member&gt;();\n        for (var user : users) {\n            final Member member = user.getMember();\n            if (member == null) continue;\n\n            if (!event.getGuild().getSelfMember().canInteract(member)) {\n                higherMembers.add(member);\n            }\n        }\n\n        if (!higherMembers.isEmpty()) {\n            final String mentions = higherMembers.stream().map(IMentionable::getAsMention).collect(Collectors.joining());\n            event.reply(\"Cannot ban \" + mentions + \" as they have equal/higher roles\")\n                    .setEphemeral(true)\n                    .queue();\n            return;\n        }\n\n        event.deferReply(true).queue();\n\n        event.getGuild().ban(users, Duration.of(timeframe, unit.toChronoUnit()))\n                .queue(response -&gt; {\n                    event.getHook().sendMessageFormat(\"Banned %s users, %s failed\", response.getBannedUsers().size(), response.getFailedUsers().size()).queue();\n                }, new ErrorHandler()\n                        .handle(ErrorResponse.MISSING_PERMISSIONS, exception -&gt; {\n                            event.getHook().sendMessage(\"Could not ban users due to missing permissions\").queue();\n                        })\n                        .handle(ErrorResponse.FAILED_TO_BAN_USERS, exception -&gt; {\n                            event.getHook().sendMessage(\"Could not ban anyone\").queue();\n                        })\n                );\n    }\n}\n</code></pre>"},{"location":"using-commands/advanced-options/#advanced-code-declared-options","title":"Advanced code-declared options","text":"<p>The Kotlin DSL also lets you do more, for example, using loops to generate commands, or even options. It also allows you to create more complex options, such as having multiple options in one parameter.</p> <p>Distinction between parameters and options</p> <p>Method parameters are what you expect, a simple value in your method, but for the framework, parameters might be a complex object (composed of multiple options), or a single option, whether it's an injected service, a Discord option or a generated value.</p> <p>i.e., A parameter might be a single or multiple options, but an option is always a single value.</p>"},{"location":"using-commands/advanced-options/#composite-parameters","title":"Composite parameters","text":"<p>These are parameters composed of multiple options, of any type, which gets merged into one parameter by using an aggregator.</p> <p>Tip</p> <p>This is how varargs are implemented, they are a loop that generates N options, where X options are optional.</p> <p>Creating an aggregated parameter</p> <p>Here is how you can use aggregated parameters to create a message delete timeframe, out of a <code>Long</code> and a <code>TimeUnit</code>.</p> The aggregated object<pre><code>// This data class is practically pointless;\n// this is just to demonstrate how you can group parameters together,\n// so you can benefit from functions/backed properties limited to your parameters,\n// without polluting classes with extensions\ndata class DeleteTimeframe(val time: Long, val unit: TimeUnit) {\n    override fun toString(): String = \"$time ${unit.name.lowercase()}\"\n}\n</code></pre> The aggregated parameter declaration<pre><code>@Command\nclass SlashBan {\n    @AppDeclaration\n    fun onDeclare(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"ban\", function = SlashBan::onSlashBan) {\n            ...\n\n            aggregate(declaredName = \"timeframe\", aggregator = ::DeleteTimeframe) {\n                option(declaredName = \"time\") {\n                    description = \"The timeframe of messages to delete with the specified unit\"\n                }\n\n                option(declaredName = \"unit\") {\n                    description = \"The unit of the delete timeframe\"\n\n                    usePredefinedChoices = true\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>The aggregating function can be a reference to the object's constructor, or a function taking the options and returning an object of the corresponding type. </p>"},{"location":"using-commands/advanced-options/#kotlins-inline-classes","title":"Kotlin's inline classes","text":"<p>Input options as well as varargs can be encapsulated in an inline class, allowing you to define simple computable properties and functions for types where defining an extension makes no sense. (Like adding an extension, that's specific to only one command, on a <code>String</code>)</p> <p>Using inline classes</p> <pre><code>private val spaceDelimiter = Regex(\"\"\"\\s+\"\"\")\n\n@JvmInline\nvalue class Sentence(val value: String) {\n    val words: List&lt;String&gt; get() = spaceDelimiter.split(value)\n}\n\n@Command\nclass SlashInlineWords : ApplicationCommand() {\n    @JDASlashCommand(name = \"words\", description = \"Extracts the words of a sentence\")\n    suspend fun onSlashWords(event: GuildSlashEvent, @SlashOption(description = \"Input sentence\") sentence: Sentence) {\n        event.reply_(\"The words are: ${sentence.words}\", ephemeral = true).await()\n    }\n}\n</code></pre>"},{"location":"using-commands/common-command-details/","title":"Common command details","text":"<p>All commands can be defined by either using annotations or a DSL (for Kotlin users).</p> <p>In both cases, classes containing commands need to be annotated with <code>@Command</code>,  which will also register your class for dependency injection.</p>"},{"location":"using-commands/common-command-details/#defining-the-command-method","title":"Defining the command method","text":"<p>Whether you're using annotated or DSL commands, you will have to write a method, which holds the user inputs as parameters.</p> <p>The method must be public, non-static, with the first parameter being the event required for the command type of your choice.</p> <p>The command methods support coroutines, as well as nullable options, and optionals.</p> A slash command with everything mentioned above KotlinJava <pre><code>suspend fun example(event: GuildSlashEvent, string: String, user: User?, integer: Int = 42/*(1)!*/) {}    \n</code></pre> <ol> <li>Optional parameters make the Discord option optional too.</li> </ol> <pre><code>public void example(@NotNull GuildSlashEvent event, @NotNull String string, @Nullable User user) {}\n</code></pre>"},{"location":"using-commands/common-command-details/#annotated-commands","title":"Annotated commands","text":"<p>Annotations let you create commands easily, but are harder to read, cannot be created dynamically, and require usage of other methods to retrieve other values (such as choices for slash command options).</p> <p>Requirements of such commands are specified on the command annotation.</p>"},{"location":"using-commands/common-command-details/#dsl-commands-kotlin","title":"DSL commands (Kotlin)","text":"<p>DSL commands were added in V3 to help create commands dynamically, whether it's to let the user filter commands themselves, or adding subcommands/options in a loop; you can almost do anything you want while keeping the simplicity of your command method.</p> <p>Commands can be declared by implementing an interface, which will allow you to add commands using the provided manager.</p>"},{"location":"using-commands/application-commands/option-resolvers/","title":"Adding option resolvers","text":"<p>Option resolvers help you support other types for your command options, such as <code>TimeUnit</code>, or any object of your own.</p> <p>Slash command option resolvers specify which option type will be used on Discord, and will handle the conversion from the Discord value to the corresponding object.</p> <p>The class implementing the resolver, or the function returning a resolver, must be annotated with <code>@Resolver</code>.</p> <p>Note</p> <p><code>@Resolver</code> is one of the annotations that are considered as a service annotation. This means that it behaves exactly the same as if you had used <code>@BService</code>, except here the annotation is more meaningful.</p>"},{"location":"using-commands/application-commands/option-resolvers/#implementation","title":"Implementation","text":"<p>For that, you need a class annotated with <code>@Resolver</code> extending <code>ClassParameterResolver</code>, and implementing <code>SlashParameterResolver</code>.</p> <p>The first type parameter is the type of your resolver implementation, and the second type is what the resolver returns.</p> <p>A <code>TimeUnit</code> resolver</p> KotlinJava <pre><code>@Resolver\nclass TimeUnitResolver :\n    ClassParameterResolver&lt;TimeUnitResolver, TimeUnit&gt;(TimeUnit::class),\n    SlashParameterResolver&lt;TimeUnitResolver, TimeUnit&gt; {\n\n    override val optionType: OptionType = OptionType.STRING\n\n    // This is all you need to implement to support predefined choices\n    override fun getPredefinedChoices(guild: Guild?): Collection&lt;Choice&gt; {\n        return listOf(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n            // The Resolvers class helps us by providing resolvers for any enum type.\n            // We're just using the helper method to change an enum value to a more natural name.\n            .map { Choice(it.toHumanName(), it.name) }\n    }\n\n    override suspend fun resolveSuspend(\n        info: SlashCommandInfo,\n        event: CommandInteractionPayload,\n        optionMapping: OptionMapping\n    ): TimeUnit = enumValueOf&lt;TimeUnit&gt;(optionMapping.asString)\n}\n</code></pre> <pre><code>@Resolver\npublic class TimeUnitResolver\n        extends ClassParameterResolver&lt;TimeUnitResolver, TimeUnit&gt;\n        implements SlashParameterResolver&lt;TimeUnitResolver, TimeUnit&gt; {\n\n    public TimeUnitResolver() {\n        super(TimeUnit.class);\n    }\n\n    @NotNull\n    @Override\n    public OptionType getOptionType() {\n        return OptionType.STRING;\n    }\n\n    @NotNull\n    @Override\n    public Collection&lt;Command.Choice&gt; getPredefinedChoices(@Nullable Guild guild) {\n        return Stream.of(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                // The Resolvers class helps us by providing resolvers for any enum type.\n                // We're just using the helper method to change an enum value to a more natural name.\n                .map(u -&gt; new Command.Choice(Resolvers.toHumanName(u), u.name()))\n                .toList();\n    }\n\n    @Nullable\n    @Override\n    public TimeUnit resolve(@NotNull SlashCommandInfo info, @NotNull CommandInteractionPayload event, @NotNull OptionMapping optionMapping) {\n        return TimeUnit.valueOf(optionMapping.getAsString());\n    }\n}\n</code></pre> <p>As you can see, this defines the slash command's option to be a string,  and provides predefined choices, letting you easily use them in your commands.</p>"},{"location":"using-commands/application-commands/option-resolvers/#built-in-resolver-generators","title":"Built-in resolver generators","text":"<p>The framework also provides functions in <code>Resolvers</code> to do most of the work for some types, all you need to do is declare a service factory with <code>@Resolver</code> and use the provided methods.</p> <p>Note</p> <p>Currently there is only a factory for enum resolvers, but others might be added in the future.</p> <p>How to easily make a resolver for an enum type</p> KotlinJava <p><pre><code>object TimeUnitResolverSimplified {\n    // The displayed name should be lowercase with the first letter uppercase, see Resolvers#toHumanName\n    @Resolver\n    fun getTimeUnitResolverSimplified() = enumResolver&lt;TimeUnit&gt;(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n}\n</code></pre> As this functions as a service factory, the method needs to be in an <code>object</code> or have a no-arg constructor.</p> <p><pre><code>public class TimeUnitResolverSimplifiedJava {\n    @Resolver\n    public static ParameterResolver&lt;?, TimeUnit&gt; getTimeUnitResolverSimplified() {\n        // The displayed name should be lowercase with the first letter uppercase, see Resolvers#toHumanName\n        return Resolvers.enumResolver(TimeUnit.class, EnumSet.of(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)).build();\n    }\n}\n</code></pre> As this functions as a service factory, the method needs to be static.</p>"},{"location":"using-commands/application-commands/using-autocomplete/","title":"Using autocomplete","text":"<p>Autocomplete lets you have options where you can give suggestions to the user while they type, the framework allows you to return a collection of choices,  choice-compatible types such as <code>String</code>, <code>Long</code> and <code>Double</code>, or even custom types, all of which can be cached.</p> <p>Note</p> <p>Autocompleted options do not force the user to choose one of the returned choices, they can still type anything.</p>"},{"location":"using-commands/application-commands/using-autocomplete/#creating-autocomplete-handlers","title":"Creating autocomplete handlers","text":"Code-declaredAnnotated <p>You will have to implement the <code>AutocompleteHandlerProvider</code>, enabling you to declare autocomplete handlers using the manager.</p> <p>You can optionally put a name on the handler, if you plan on using <code>autocompleteByName</code>,  however, that's not necessary when using <code>autocompleteByFunction</code>.</p> <pre><code>@BService\nclass SlashWordAutocompleteDsl : AutocompleteHandlerProvider {\n    // https://en.wikipedia.org/wiki/Dolch_word_list#Dolch_list:_Nouns\n    // but 30 words\n    private val words = listOf(\n        \"apple\", \"baby\", \"back\", \"ball\", \"bear\", \"bed\", \"bell\", \"bird\", \"birthday\", \"boat\",\n        \"box\", \"boy\", \"bread\", \"brother\", \"cake\", \"car\", \"cat\", \"chair\", \"chicken\", \"children\",\n        \"Christmas\", \"coat\", \"corn\", \"cow\", \"day\", \"dog\", \"doll\", \"door\", \"duck\", \"egg\"\n    )\n\n    // You can also make this return a collection of Choice, see the AutocompleteManager#autocomplete docs\n    fun onWordAutocomplete(event: CommandAutoCompleteInteractionEvent): Collection&lt;String&gt; {\n        // Here you would typically filter the words based on what the user inputs,\n        // but it is already done when you return a Collection&lt;String&gt;\n        return words\n    }\n\n    // All autocomplete declarations run before any command is registered,\n    // so you can, in theory, add autocomplete handlers anywhere,\n    // and use them in any command.\n    override fun declareAutocomplete(manager: AutocompleteManager) {\n        manager.autocomplete(::onWordAutocomplete)\n    }\n}\n</code></pre> <p>You will have to use <code>@AutocompleteHandler</code>, give it a unique name, I'd recommend using one similar to <code>ClassName: optionName</code>, it will be useful to reference it in commands later on.</p> <p>Info</p> <p>An annotated autocomplete handler can still be referenced by name  and by function in code-declared commands.</p> KotlinJava <pre><code>@Handler // Required by the AutocompleteHandler annotation, can be replaced with @Command\nclass SlashWordAutocomplete {\n    // https://en.wikipedia.org/wiki/Dolch_word_list#Dolch_list:_Nouns\n    // but 30 words\n    private val words = listOf(\n        \"apple\", \"baby\", \"back\", \"ball\", \"bear\", \"bed\", \"bell\", \"bird\", \"birthday\", \"boat\",\n        \"box\", \"boy\", \"bread\", \"brother\", \"cake\", \"car\", \"cat\", \"chair\", \"chicken\", \"children\",\n        \"Christmas\", \"coat\", \"corn\", \"cow\", \"day\", \"dog\", \"doll\", \"door\", \"duck\", \"egg\"\n    )\n\n    // You can also make this return a collection of Choice, see the annotation docs\n    @AutocompleteHandler(WORD_AUTOCOMPLETE_NAME)\n    fun onWordAutocomplete(event: CommandAutoCompleteInteractionEvent): Collection&lt;String&gt; {\n        // Here you would typically filter the words based on what the user inputs,\n        // but it is already done when you return a Collection&lt;String&gt;\n        return words\n    }\n\n    companion object {\n        const val WORD_AUTOCOMPLETE_NAME = \"SlashWord: word\"\n    }\n}\n</code></pre> <pre><code>@Handler // Required by the AutocompleteHandler annotation, can be replaced with @Command\npublic class SlashWordAutocomplete extends ApplicationCommand {\n    // https://en.wikipedia.org/wiki/Dolch_word_list#Dolch_list:_Nouns\n    // but 30 words\n    private static final List&lt;String&gt; WORDS = List.of(\n            \"apple\", \"baby\", \"back\", \"ball\", \"bear\", \"bed\", \"bell\", \"bird\", \"birthday\", \"boat\",\n            \"box\", \"boy\", \"bread\", \"brother\", \"cake\", \"car\", \"cat\", \"chair\", \"chicken\", \"children\",\n            \"Christmas\", \"coat\", \"corn\", \"cow\", \"day\", \"dog\", \"doll\", \"door\", \"duck\", \"egg\"\n    );\n    public static final String WORD_AUTOCOMPLETE_NAME = \"SlashWord: word\";\n\n    // You can also make this return a collection of Choice, see the annotation docs\n    @AutocompleteHandler(WORD_AUTOCOMPLETE_NAME)\n    public Collection&lt;String&gt; onWordAutocomplete(CommandAutoCompleteInteractionEvent event) {\n        // Here you would typically filter the words based on what the user inputs,\n        // but it is already done when you return a Collection&lt;String&gt;\n        return WORDS;\n    }\n}\n</code></pre> <p>You may also configure other properties:</p> <ul> <li><code>showUserInput</code>: Makes the first choice be the user's own input</li> <li><code>mode</code>: Lets you configure out the automatic choice sorter (for <code>String</code>/<code>Long</code>/<code>Double</code> only)</li> </ul> <p>Sorting autocomplete results of <code>Choice</code> and custom types</p> <p>Sorting results by relevancy is a tricky task, while it can be as simple as <code>myItemName.startsWith(input)</code> you can try to use <code>AutocompleteAlgorithms</code> to easily sort the results.  This is what gets applied on primitive types, but the results won't always be the best.</p> <p>It may sometimes makes more sense to use one \"similarity\" algorithm over another,  depending on what user input you expect, and what the source items are, you can experiment different algos from the java-string-similarity library, already included in the framework.</p> <p>You are encouraged to to try inputs against different algos, and find what works the best,  which one could filter the results of the previous algo, etc.</p>"},{"location":"using-commands/application-commands/using-autocomplete/#caching","title":"Caching","text":"<p>When the results are stable, you can enable autocomplete caching, saving time when a user types the same query.</p> Code-declaredAnnotated <p>To enable it, configure the cache using the <code>cache</code>  configurer.</p> <p>By default it will cache by using the user input, but you can add arguments to the cache key by:</p> <ul> <li>Adding the user ID with <code>userLocal</code></li> <li>Adding the channel ID with <code>channelLocal</code></li> <li>Adding the guild ID with <code>guildLocal</code></li> <li>Adding values of options by their names in <code>compositeKeys</code> </li> </ul> <p>To enable it, configure the cache using <code>@CacheAutocomplete</code>.</p> <p>By default it will cache by using the user input, but you can add arguments to the cache key by:</p> <ul> <li>Adding the user ID with <code>userLocal</code></li> <li>Adding the channel ID with <code>channelLocal</code></li> <li>Adding the guild ID with <code>guildLocal</code></li> <li>Adding values of options by their names in <code>compositeKeys</code></li> </ul> <p>Note</p> <p>If the outputs for the same input are stable but may rarely change (think, a list that updates daily), you can invalidate autocomplete caches when it eventually does.</p> <p>Tip</p> <p>You can also disable the autocomplete cache while developing your bot with the disableAutocompleteCache property, this should help you test your handler live, using hotswap.</p>"},{"location":"using-commands/application-commands/using-autocomplete/#transforming-elements-into-choices","title":"Transforming elements into choices","text":"<p>If you wish to return collections of anything but the default supported types, you will need to create a service which transforms those objects into choices, by implementing <code>AutocompleteTranformer</code>.</p> <p>Example</p> KotlinJava FullName.kt<pre><code>data class FullName(val firstName: String, val secondName: String)\n</code></pre> FullNameTransformer.kt<pre><code>@BService\nclass FullNameTransformer : AutocompleteTransformer&lt;FullName&gt; {\n    override val elementType: Class&lt;FullName&gt; = FullName::class.java\n\n    override fun apply(e: FullName): Command.Choice {\n        return Command.Choice(\"${e.firstName} ${e.secondName}\", \"${e.firstName}|${e.secondName}\")\n    }\n}\n</code></pre> FullName.java<pre><code>public record FullName(String firstName, String secondName) { }\n</code></pre> FullNameTransformer.java<pre><code>@BService\npublic class FullNameTransformer implements AutocompleteTransformer&lt;FullName&gt; {\n    @NotNull\n    @Override\n    public Class&lt;FullName&gt; getElementType() {\n        return FullName.class;\n    }\n\n    @NotNull\n    @Override\n    public Command.Choice apply(@NotNull FullName fullName) {\n        return new Command.Choice(\n                \"%s %s\".formatted(fullName.firstName(), fullName.secondName()),\n                \"%s|%s\".formatted(fullName, fullName.secondName())\n        );\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/using-autocomplete/#usage-in-commands","title":"Usage in commands","text":"<p>Discover how to use your autocomplete handlers on:</p> <ul> <li>Annotated slash commands</li> <li>Code-declared slash commands</li> </ul>"},{"location":"using-commands/application-commands/writing-slash-commands/","title":"Creating slash commands","text":"<p>Slash commands are the new way of defining commands, even though there are limitations with them,  we do have some advantages such as being easier to fill in, choices and auto-completion.</p> <p>If you wish to handle application commands yourself, you can disable them by disabling <code>BApplicationConfig#enable</code>.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#defining-the-command-method","title":"Defining the command method","text":"<p>Tip</p> <p>Make sure you read the common command requirements first!</p> <p>In addition to the common requirements, the first parameter must be <code>GlobalSlashEvent</code> for global commands or <code>GuildSlashEvent</code> for guild commands, or guild-only global commands (default).</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#annotated-commands","title":"Annotated commands","text":"<p>Annotated command methods must be annotated with <code>@JDASlashCommand</code>, where you can set the scope, name, description, etc...,  while the declaring class must extend <code>ApplicationCommand</code>.</p> <p>Why do I need to extend <code>ApplicationCommand</code>?</p> <p>As a limitation of annotated commands,  you are required to extend this class as it allows the framework to ask your commands for stuff, like what guilds a command should be pushed to, getting a value generator for one of their options, and also getting choices.</p> <p>Example</p> KotlinJava <pre><code>@Command\nclass SlashPingKotlin : ApplicationCommand() {\n    // Default scope is global, guild-only (GUILD_NO_DM)\n    @JDASlashCommand(name = \"ping\", description = \"Pong!\")\n    suspend fun onSlashPing(event: GuildSlashEvent) {\n        event.deferReply(true).queue()\n\n        val ping = event.jda.getRestPing().await()\n        event.hook.editOriginal(\"Pong! $ping ms\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashPing extends ApplicationCommand {\n    // Default scope is global, guild-only (GUILD_NO_DM)\n    @JDASlashCommand(name = \"ping\", description = \"Pong!\")\n    public void onSlashPing(GuildSlashEvent event) {\n        event.deferReply(true).queue();\n\n        event.getJDA().getRestPing().queue(ping -&gt; {\n            event.getHook().editOriginal(\"Pong! \" + ping + \" ms\").queue();\n        });\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#subcommands","title":"Subcommands","text":"<p>To make a subcommand, set the <code>name</code> and <code>subcommand</code> on the annotation.</p> <p>You will also need to add a <code>@TopLevelSlashCommandData</code>, it must only be used once per top-level command, this allows you to set top-level attributes.</p> <p>Example</p> KotlinJava <pre><code>@Command\nclass SlashTag : ApplicationCommand() {\n    // Data for /tag create\n    @JDASlashCommand(name = \"tag\", subcommand = \"create\", description = \"Creates a tag\")\n    // Data for /tag\n    @TopLevelSlashCommandData(description = \"Manage tags\")\n    fun onSlashTagCreate(event: GuildSlashEvent) {\n        // ...\n    }\n\n    // Data for /tag delete\n    @JDASlashCommand(name = \"tag\", subcommand = \"delete\", description = \"Deletes a tag\")\n    fun onSlashTagDelete(event: GuildSlashEvent) {\n        // ...\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashTag extends ApplicationCommand {\n    // Data for /tag create\n    @JDASlashCommand(name = \"tag\", subcommand = \"create\", description = \"Creates a tag\")\n    // Data for /tag\n    @TopLevelSlashCommandData(description = \"Manage tags\")\n    public void onSlashTagCreate(GuildSlashEvent event) {\n        // ...\n    }\n\n    // Data for /tag delete\n    @JDASlashCommand(name = \"tag\", subcommand = \"delete\", description = \"Deletes a tag\")\n    public void onSlashTagDelete(GuildSlashEvent event) {\n        // ...\n    }\n}\n</code></pre> <p>Note</p> <p>You cannot have both subcommands and top-level commands (i.e., an annotation with only <code>name</code> set).</p> <p>However, you can have both subcommand groups and subcommands groups containing subcommands.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#adding-options","title":"Adding options","text":"<p>Options can be added with a parameter annotated with <code>@SlashOption</code>.</p> <p>All supported types are documented under <code>ParameterResolver</code>, and other types can be added.</p> <p>Example</p> KotlinJava <pre><code>@Command\nclass SlashSayKotlin : ApplicationCommand() {\n    @JDASlashCommand(name = \"say\", description = \"Says something\")\n    suspend fun onSlashSay(event: GuildSlashEvent, @SlashOption(description = \"What to say\") content: String) {\n        event.reply(content).await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashSay extends ApplicationCommand {\n    @JDASlashCommand(name = \"say\", description = \"Says something\")\n    public void onSlashSay(GuildSlashEvent event, @SlashOption(description = \"What to say\") String content) {\n        event.reply(content).queue();\n    }\n}\n</code></pre> <p>Inferred option names</p> <p>Display names of options can be set on the annotation, but can also be deduced from the parameter name, this is natively supported in Kotlin, but for Java, you will need to enable parameter names on the Java compiler.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-choices","title":"Using choices","text":"<p>You must override <code>getOptionChoices</code> in order to return a list of choices,  be careful to check against the command path as well as the option's display name.</p> <p>Example</p> KotlinJava <pre><code>@Command\nclass SlashConvertKotlin : ApplicationCommand() {\n    override fun getOptionChoices(guild: Guild?, commandPath: CommandPath, optionName: String): List&lt;Choice&gt; {\n        if (commandPath.name == \"convert\") {\n            if (optionName == \"from\" || optionName == \"to\") {\n                return listOf(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                    // The Resolvers class helps us by providing resolvers for any enum type.\n                    // We're just using the helper method to change an enum value to a more natural name.\n                    .map { Choice(Resolvers.toHumanName(it), it.name) }\n            }\n        }\n\n        return super.getOptionChoices(guild, commandPath, optionName)\n    }\n\n    @JDASlashCommand(name = \"convert\", description = \"Convert time to another unit\")\n    suspend fun onSlashConvert(\n        event: GuildSlashEvent,\n        @SlashOption(description = \"The time to convert\") time: Long,\n        @SlashOption(description = \"The unit to convert from\") from: TimeUnit,\n        @SlashOption(description = \"The unit to convert to\") to: TimeUnit\n    ) {\n        event.reply(\"${to.convert(time, from)} ${to.name.lowercase()}\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashConvert extends ApplicationCommand {\n    @NotNull\n    @Override\n    public List&lt;Choice&gt; getOptionChoices(@Nullable Guild guild, @NotNull CommandPath commandPath, @NotNull String optionName) {\n        if (commandPath.getName().equals(\"convert\")) {\n            if (optionName.equals(\"from\") || optionName.equals(\"to\")) {\n                return Stream.of(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                        // The Resolvers class helps us by providing resolvers for any enum type.\n                        // We're just using the helper method to change an enum value to a more natural name.\n                        .map(u -&gt; new Choice(Resolvers.toHumanName(u), u.name()))\n                        .toList();\n            }\n        }\n\n        return super.getOptionChoices(guild, commandPath, optionName);\n    }\n\n    @JDASlashCommand(name = \"convert\", description = \"Convert time to another unit\")\n    public void onSlashConvert(\n            GuildSlashEvent event,\n            @SlashOption(description = \"The time to convert\") long time,\n            @SlashOption(description = \"The unit to convert from\") TimeUnit from,\n            @SlashOption(description = \"The unit to convert to\") TimeUnit to\n    ) {\n        event.reply(to.convert(time, from) + \" \" + to.name().toLowerCase()).queue();\n    }\n}\n</code></pre> <p>As you can see, despite the short choice list,  the method is quite lengthy and causes duplications with multiple commands. This issue is solved with predefined choices.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-autocomplete","title":"Using autocomplete","text":"<p>Learn how to create an autocomplete handler here</p> <p>Enabling autocompletion for an option is done by referencing an existing handler, in the <code>autocomplete</code> property of your <code>@SlashOption</code>.</p> <p>Example</p> <p>Using the autocomplete handler we made \"Creating autocomplete handlers\":</p> KotlinJava <pre><code>@Command\nclass SlashWord : ApplicationCommand() {\n    @JDASlashCommand(name = \"word\", description = \"Autocompletes a word\")\n    suspend fun onSlashWord(\n        event: GuildSlashEvent,\n        @SlashOption(description = \"The word\", autocomplete = SlashWordAutocomplete.WORD_AUTOCOMPLETE_NAME) word: String,\n    ) {\n        event.reply_(\"Your word was $word\", ephemeral = true).await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashWord extends ApplicationCommand {\n    @JDASlashCommand(name = \"word\", description = \"Autocompletes a word\")\n    public void onSlashWord(GuildSlashEvent event,\n                            @SlashOption(description = \"The word\", autocomplete = SlashWordAutocomplete.WORD_AUTOCOMPLETE_NAME) String word) {\n        event.reply(\"Your word was \" + word).setEphemeral(true).queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#generated-values","title":"Generated values","text":"<p>Generated values are parameters that get their values from a lambda everytime a command is run.</p> <p>You must give one by overriding <code>ApplicationCommand#getGeneratedValueSupplier</code>,  similarly to adding choices.</p> <p>As always, make sure to check against the command path as well as the option's display name.</p> <p>Example</p> KotlinJava <pre><code>@Command\nclass SlashCreateTimeKotlin : ApplicationCommand() {\n    override fun getGeneratedValueSupplier(\n        guild: Guild?,\n        commandId: String?,\n        commandPath: CommandPath,\n        optionName: String,\n        parameterType: ParameterType\n    ): ApplicationGeneratedValueSupplier {\n        if (commandPath.name == \"create_time\") {\n            if (optionName == \"timestamp\") {\n                // Create a snapshot of the instant the command was created\n                val now = Instant.now()\n                // Give back the instant snapshot, as this will be called every time the command runs\n                return ApplicationGeneratedValueSupplier { now }\n            }\n        }\n\n        return super.getGeneratedValueSupplier(guild, commandId, commandPath, optionName, parameterType)\n    }\n\n    @JDASlashCommand(name = \"create_time\", description = \"Shows the creation time of this command\")\n    suspend fun onSlashCreateTime(\n        event: GuildSlashEvent,\n        @GeneratedOption timestamp: Instant\n    ) {\n        event.reply(\"I was created on ${TimeFormat.DATE_TIME_SHORT.format(timestamp)}\").await()\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashCreateTime extends ApplicationCommand {\n    @NotNull\n    @Override\n    public ApplicationGeneratedValueSupplier getGeneratedValueSupplier(\n            @Nullable Guild guild,\n            @Nullable String commandId,\n            @NotNull CommandPath commandPath,\n            @NotNull String optionName,\n            @NotNull ParameterType parameterType\n    ) {\n        if (commandPath.getName().equals(\"create_time\")) {\n            if (optionName.equals(\"timestamp\")) {\n                // Create a snapshot of the instant the command was created\n                final Instant now = Instant.now();\n                // Give back the instant snapshot, as this will be called every time the command runs\n                return event -&gt; now;\n            }\n        }\n\n        return super.getGeneratedValueSupplier(guild, commandId, commandPath, optionName, parameterType);\n    }\n\n    @JDASlashCommand(name = \"create_time\", description = \"Shows the creation time of this command\")\n    public void onSlashTimeIn(\n            GuildSlashEvent event,\n            @GeneratedOption Instant timestamp\n    ) {\n        event.reply(\"I was created on \" + TimeFormat.DATE_TIME_SHORT.format(timestamp)).queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#dsl-commands-kotlin","title":"DSL commands (Kotlin)","text":"<p>Commands can be DSL-declared by either implementing:</p> <ul> <li><code>GlobalApplicationCommandProvider</code> (for global / guild-only global application commands), or,</li> <li><code>GuildApplicationCommandProvider</code> (for guild-specific application commands)</li> </ul> <p>You can then use the <code>slashCommand</code> method on the <code>manager</code>, give it the command name, the command method,  and then configure your command.</p> <p>Tip</p> <p>You are allowed to not add any command at all, for example,  if the <code>guild</code> in <code>GuildApplicationCommandManager</code> isn't a guild you want the command to appear in.</p> <p>Example</p> <pre><code>@Command\nclass SlashPingKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashPing(event: GuildSlashEvent) {\n        event.deferReply(true).queue()\n\n        val ping = event.jda.getRestPing().await()\n        event.hook.editOriginal(\"Pong! $ping ms\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        // Default scope is global, guild-only (GUILD_NO_DM)\n        manager.slashCommand(\"ping\", function = ::onSlashPing) {\n            description = \"Pong!\"\n        }\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#subcommands_1","title":"Subcommands","text":"<p>As top-level commands cannot be made alongside subcommands, the top-level <code>function</code> must be <code>null</code>.</p> <p>You can then add a subcommand by using <code>subcommand</code>, where each subcommand is its own function.</p> <p>Example</p> <pre><code>@Command\nclass SlashTagDsl : GlobalApplicationCommandProvider {\n    fun onSlashTagCreate(event: GuildSlashEvent) {\n        // ...\n    }\n\n    fun onSlashTagDelete(event: GuildSlashEvent) {\n        // ...\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        // Pass a null function as this is not a top-level command\n        manager.slashCommand(\"tag\", function = null) {\n            description = \"Manage tags\"\n\n            subcommand(\"create\", ::onSlashTagCreate) {\n                description = \"Creates a tag\"\n            }\n\n            subcommand(\"delete\", ::onSlashTagDelete) {\n                description = \"Deletes a tag\"\n            }\n        }\n    }\n}\n</code></pre> <p>Info</p> <p>You can still create both subcommands, and subcommand groups containg subcommands.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#adding-options_1","title":"Adding options","text":"<p>Options can be added with a parameter and declaring it using <code>option</code> in your command builder, where the <code>declaredName</code> is the name of your parameter, the block will let you change the description, choices, etc.</p> <p>All supported types are documented under <code>ParameterResolver</code>, and other types can be added.</p> <p>Example</p> <pre><code>@Command\nclass SlashSayKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashSay(event: GuildSlashEvent, content: String) {\n        event.reply(content).await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"say\", function = ::onSlashSay) {\n            description = \"Says something\"\n\n            option(\"content\") {\n                description = \"What to say\"\n            }\n        }\n    }\n}\n</code></pre> <p>Tip</p> <p>You can override the option name by setting <code>optionName</code> in the option declaration: <pre><code>option(\"content\", optionName = \"sentence\") {\n    ...\n}\n</code></pre></p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-choices_1","title":"Using choices","text":"<p>Adding choices is very straight forward, you only have to give a list of choices to the <code>choice</code> property.</p> <p>Example</p> <pre><code>@Command\nclass SlashConvertKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashConvert(event: GuildSlashEvent, time: Long, from: TimeUnit, to: TimeUnit) {\n        event.reply(\"${to.convert(time, from)} ${to.name.lowercase()}\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"convert\", function = ::onSlashConvert) {\n            description = \"Convert time to another unit\"\n\n            option(\"time\") {\n                description = \"The time to convert\"\n            }\n\n            option(\"from\") {\n                description = \"The unit to convert from\"\n\n                choices = listOf(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                    // The Resolvers class helps us by providing resolvers for any enum type.\n                    // We're just using the helper method to change an enum value to a more natural name.\n                    .map { Choice(Resolvers.toHumanName(it), it.name) }\n            }\n\n            option(\"to\") {\n                description = \"The unit to convert to\"\n\n                choices = listOf(TimeUnit.SECONDS, TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS)\n                    // The Resolvers class helps us by providing resolvers for any enum type.\n                    // We're just using the helper method to change an enum value to a more natural name.\n                    .map { Choice(Resolvers.toHumanName(it), it.name) }\n            }\n        }\n    }\n}\n</code></pre> <p>As you can see, despite the short choice list, this causes duplications with multiple commands. This issue is solved with predefined choices.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-autocomplete_1","title":"Using autocomplete","text":"<p>Learn how to create an autocomplete handler here</p> <p>Enabling autocompletion for an option is done by referencing an existing handler, either using autocompleteByFunction or autocompleteByName.</p> <p>Tip</p> <p>I recommend using autocompleteByFunction  as it avoids typing the name twice.</p> <p>Example</p> <p>Using the autocomplete handler we made \"Creating autocomplete handlers\":</p> <pre><code>@Command\nclass SlashWordDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashWord(event: GuildSlashEvent, word: String) {\n        event.reply_(\"Your word was $word\", ephemeral = true).await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"word\", function = ::onSlashWord) {\n            description = \"Autocompletes a word\"\n\n            option(\"word\") {\n                description = \"The word\"\n\n                // Use an existing autocomplete declaration\n                autocompleteByFunction(SlashWordAutocompleteDsl::onWordAutocomplete)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#generated-values_1","title":"Generated values","text":"<p>Generated values are a command parameter that gets their values computed by the given block everytime the command run.</p> <p>Contrary to the annotated commands, no checks are required, as this is tied to the currently built command.</p> <p>Example</p> <pre><code>@Command\nclass SlashCreateTimeKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashCreateTime(event: GuildSlashEvent, timestamp: Instant) {\n        event.reply(\"I was created on ${TimeFormat.DATE_TIME_SHORT.format(timestamp)}\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"create_time\", function = ::onSlashCreateTime) {\n            description = \"Shows the creation time of this command\"\n\n            // Create a snapshot of the instant the command was created\n            val now = Instant.now()\n            generatedOption(\"timestamp\") {\n                // Give back the instant snapshot, as this will be called every time the command is run\n                return@generatedOption now\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#default-description","title":"Default description","text":"<p>You can avoid setting the (non-localized) descriptions of your commands and options  by putting them in a localization file, using the root locale (i.e., no locale suffix), and have your localization bundle registered with <code>BApplicationConfigBuilder#addLocalizations</code>.</p> The same commands as before, but without the descriptions KotlinKotlin (DSL)Java <pre><code>@Command\nclass SlashSayDefaultDescriptionKotlin : ApplicationCommand() {\n    @JDASlashCommand(name = \"say_default_description\")\n    suspend fun onSlashSayDefaultDescription(event: GuildSlashEvent, @SlashOption content: String) {\n        event.reply(content).await()\n    }\n}\n</code></pre> <pre><code>@Command\nclass SlashSayDefaultDescriptionKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashSayDefaultDescription(event: GuildSlashEvent, content: String) {\n        event.reply(content).await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"say_default_description\", function = ::onSlashSayDefaultDescription) {\n            option(\"content\")\n        }\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashSayDefaultDescription extends ApplicationCommand {\n    @JDASlashCommand(name = \"say_default_description\")\n    public void onSlashSayDefaultDescription(GuildSlashEvent event, @SlashOption String content) {\n        event.reply(content).queue();\n    }\n}\n</code></pre> <p>Adding the root localization bundle</p> <p>For the given resource bundle: src/main/resources/bc_localization/Commands.json<pre><code>{\n  \"say_default_description\": {\n    \"description\": \"Says something\",\n    \"options\": {\n      \"content.description\": \"What to say\"\n    }\n  }\n}\n</code></pre></p> <p>You can add the bundle by calling <code>BApplicationConfigBuilder#addLocalizations(\"Commands\")</code>.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#using-predefined-choices","title":"Using predefined choices","text":"<p>If your choices stay the same for every command, you can improve re-usability and avoid extra code by using choices on the resolver's level, that is, the resolver will return the choices used for every option of their type.</p> <p>All you now need to do is enable <code>usePredefinedChoices</code> on your option.</p> <p>Example</p> <p>Here, the resolver for <code>TimeUnit</code> is already defined and will be explained in Adding option resolvers.</p> KotlinKotlin (DSL)Java <pre><code>@Command\nclass SlashConvertSimplifiedKotlin : ApplicationCommand() {\n    @JDASlashCommand(name = \"convert_simplified\", description = \"Convert time to another unit\")\n    suspend fun onSlashConvertSimplified(\n        event: GuildSlashEvent,\n        @SlashOption(description = \"The time to convert\") time: Long,\n        @SlashOption(description = \"The unit to convert from\", usePredefinedChoices = true) from: TimeUnit,\n        @SlashOption(description = \"The unit to convert to\", usePredefinedChoices = true) to: TimeUnit\n    ) {\n        event.reply(\"${to.convert(time, from)} ${to.name.lowercase()}\").await()\n    }\n}\n</code></pre> <pre><code>@Command\nclass SlashConvertSimplifiedKotlinDsl : GlobalApplicationCommandProvider {\n    suspend fun onSlashConvertSimplified(event: GuildSlashEvent, time: Long, from: TimeUnit, to: TimeUnit) {\n        event.reply(\"${to.convert(time, from)} ${to.name.lowercase()}\").await()\n    }\n\n    override fun declareGlobalApplicationCommands(manager: GlobalApplicationCommandManager) {\n        manager.slashCommand(\"convert_simplified\", function = ::onSlashConvertSimplified) {\n            description = \"Convert time to another unit\"\n\n            option(\"time\") {\n                description = \"The time to convert\"\n            }\n\n            option(\"from\") {\n                description = \"The unit to convert from\"\n\n                usePredefinedChoices = true\n            }\n\n            option(\"to\") {\n                description = \"The unit to convert to\"\n\n                usePredefinedChoices = true\n            }\n        }\n    }\n}\n</code></pre> <pre><code>@Command\npublic class SlashConvertSimplified extends ApplicationCommand {\n    @JDASlashCommand(name = \"convert_simplified\", description = \"Convert time to another unit\")\n    public void onSlashTimeInSimplified(\n            GuildSlashEvent event,\n            @SlashOption(description = \"The time to convert\") long time,\n            @SlashOption(description = \"The unit to convert from\", usePredefinedChoices = true) TimeUnit from,\n            @SlashOption(description = \"The unit to convert to\", usePredefinedChoices = true) TimeUnit to\n    ) {\n        event.reply(to.convert(time, from) + \" \" + to.toString().toLowerCase()).queue();\n    }\n}\n</code></pre>"},{"location":"using-commands/application-commands/writing-slash-commands/#update-logs","title":"Update logs","text":"<p>You can optionally get more info on what changed in your application commands, by enabling the <code>TRACE</code> logs on <code>io.github.freya022.botcommands.internal.commands.application.diff.DiffLogger</code>, or any package it is in.</p>"},{"location":"using-commands/application-commands/writing-slash-commands/#examples","title":"Examples","text":"<p>You can take a look at more examples here.</p>"}]}